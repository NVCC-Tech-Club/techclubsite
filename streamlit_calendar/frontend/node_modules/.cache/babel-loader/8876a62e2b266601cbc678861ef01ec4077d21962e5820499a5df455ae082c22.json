{"ast":null,"code":"import _toConsumableArray from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _assertThisInitialized from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n  var rect = scrollEl.getBoundingClientRect();\n  var edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n  return {\n    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n    top: rect.top + edges.borderTop - scrollEl.scrollTop\n  };\n}\nfunction getScrollFromLeftEdge(el) {\n  var scrollLeft = el.scrollLeft;\n  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'negative':\n        scrollLeft *= -1;\n      // convert to 'reverse'. fall through...\n      case 'reverse':\n        // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n        scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n    }\n  }\n  return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'reverse':\n        scrollLeft = el.scrollWidth - scrollLeft;\n        break;\n      case 'negative':\n        scrollLeft = -(el.scrollWidth - scrollLeft);\n        break;\n    }\n  }\n  el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nvar _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '-1000px';\n  el.style.width = '100px'; // must be at least the side of scrollbars or you get inaccurate values (#7335)\n  el.style.height = '100px'; // \"\n  el.style.overflow = 'scroll';\n  el.style.direction = 'rtl';\n  var innerEl = document.createElement('div');\n  innerEl.style.width = '200px';\n  innerEl.style.height = '200px';\n  el.appendChild(innerEl);\n  document.body.appendChild(el);\n  var system;\n  if (el.scrollLeft > 0) {\n    system = 'positive'; // scroll is a positive number from the left edge\n  } else {\n    el.scrollLeft = 1;\n    if (el.scrollLeft > 0) {\n      system = 'reverse'; // scroll is a positive number from the right edge\n    } else {\n      system = 'negative'; // scroll is a negative number from the right edge\n    }\n  }\n\n  removeElement(el);\n  return system;\n}\nvar STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nvar StickyScrolling = /*#__PURE__*/function () {\n  function StickyScrolling(scrollEl, isRtl) {\n    var _this = this;\n    _classCallCheck(this, StickyScrolling);\n    this.scrollEl = scrollEl;\n    this.isRtl = isRtl;\n    this.updateSize = function () {\n      var scrollEl = _this.scrollEl;\n      var els = findElements(scrollEl, STICKY_SELECTOR);\n      var elGeoms = _this.queryElGeoms(els);\n      var viewportWidth = scrollEl.clientWidth;\n      assignStickyPositions(els, elGeoms, viewportWidth);\n    };\n  }\n  _createClass(StickyScrolling, [{\n    key: \"queryElGeoms\",\n    value: function queryElGeoms(els) {\n      var scrollEl = this.scrollEl,\n        isRtl = this.isRtl;\n      var canvasOrigin = getScrollCanvasOrigin(scrollEl);\n      var elGeoms = [];\n      var _iterator = _createForOfIteratorHelper(els),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var el = _step.value;\n          var parentBound = translateRect(computeInnerRect(el.parentNode, true, true),\n          // weird way to call this!!!\n          -canvasOrigin.left, -canvasOrigin.top);\n          var elRect = el.getBoundingClientRect();\n          var computedStyles = window.getComputedStyle(el);\n          var textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n          var naturalBound = null;\n          if (textAlign === 'start') {\n            textAlign = isRtl ? 'right' : 'left';\n          } else if (textAlign === 'end') {\n            textAlign = isRtl ? 'left' : 'right';\n          }\n          if (computedStyles.position !== 'sticky') {\n            naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0),\n            // could be 'auto'\n            -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n          }\n          elGeoms.push({\n            parentBound: parentBound,\n            naturalBound: naturalBound,\n            elWidth: elRect.width,\n            elHeight: elRect.height,\n            textAlign: textAlign\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return elGeoms;\n    }\n  }]);\n  return StickyScrolling;\n}();\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n  els.forEach(function (el, i) {\n    var _elGeoms$i = elGeoms[i],\n      textAlign = _elGeoms$i.textAlign,\n      elWidth = _elGeoms$i.elWidth,\n      parentBound = _elGeoms$i.parentBound;\n    var parentWidth = parentBound.right - parentBound.left;\n    var left;\n    if (textAlign === 'center' && parentWidth > viewportWidth) {\n      left = (viewportWidth - elWidth) / 2;\n    } else {\n      // if parent container can be completely in view, we don't need stickiness\n      left = '';\n    }\n    applyStyle(el, {\n      left: left,\n      right: left,\n      top: 0\n    });\n  });\n}\nvar ClippedScroller = /*#__PURE__*/function (_BaseComponent) {\n  _inherits(ClippedScroller, _BaseComponent);\n  var _super = _createSuper(ClippedScroller);\n  function ClippedScroller() {\n    var _this2;\n    _classCallCheck(this, ClippedScroller);\n    _this2 = _super.apply(this, arguments);\n    _this2.elRef = createRef();\n    _this2.state = {\n      xScrollbarWidth: 0,\n      yScrollbarWidth: 0\n    };\n    _this2.handleScroller = function (scroller) {\n      _this2.scroller = scroller;\n      setRef(_this2.props.scrollerRef, scroller);\n    };\n    _this2.handleSizing = function () {\n      var _assertThisInitialize = _assertThisInitialized(_this2),\n        props = _assertThisInitialize.props;\n      if (props.overflowY === 'scroll-hidden') {\n        _this2.setState({\n          yScrollbarWidth: _this2.scroller.getYScrollbarWidth()\n        });\n      }\n      if (props.overflowX === 'scroll-hidden') {\n        _this2.setState({\n          xScrollbarWidth: _this2.scroller.getXScrollbarWidth()\n        });\n      }\n    };\n    return _this2;\n  }\n  _createClass(ClippedScroller, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        state = this.state,\n        context = this.context;\n      var isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n      var overcomeLeft = 0;\n      var overcomeRight = 0;\n      var overcomeBottom = 0;\n      var overflowX = props.overflowX,\n        overflowY = props.overflowY;\n      if (props.forPrint) {\n        overflowX = 'visible';\n        overflowY = 'visible';\n      }\n      if (overflowX === 'scroll-hidden') {\n        overcomeBottom = state.xScrollbarWidth;\n      }\n      if (overflowY === 'scroll-hidden') {\n        if (state.yScrollbarWidth != null) {\n          if (isScrollbarOnLeft) {\n            overcomeLeft = state.yScrollbarWidth;\n          } else {\n            overcomeRight = state.yScrollbarWidth;\n          }\n        }\n      }\n      return createElement(\"div\", {\n        ref: this.elRef,\n        className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')\n      }, createElement(Scroller, {\n        ref: this.handleScroller,\n        elRef: this.props.scrollerElRef,\n        overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX,\n        overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY,\n        overcomeLeft: overcomeLeft,\n        overcomeRight: overcomeRight,\n        overcomeBottom: overcomeBottom,\n        maxHeight: typeof props.maxHeight === 'number' ? props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0) : '',\n        liquid: props.liquid,\n        liquidIsAbsolute: true\n      }, props.children));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.handleSizing();\n      this.context.addResizeHandler(this.handleSizing);\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate(prevProps) {\n      if (this.props.forPrint && !prevProps.forPrint) {\n        return {\n          simulateScrollLeft: this.scroller.el.scrollLeft\n        };\n      }\n      return {};\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState, snapshot) {\n      var props = this.props,\n        scrollerEl = this.scroller.el;\n      if (!isPropsEqual(prevProps, props)) {\n        // an external change?\n        this.handleSizing();\n      }\n      if (snapshot.simulateScrollLeft !== undefined) {\n        scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n      } else if (!props.forPrint && prevProps.forPrint) {\n        var restoredScrollLeft = -parseInt(scrollerEl.style.left);\n        scrollerEl.style.left = '';\n        scrollerEl.scrollLeft = restoredScrollLeft;\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.context.removeResizeHandler(this.handleSizing);\n    }\n  }, {\n    key: \"needsXScrolling\",\n    value: function needsXScrolling() {\n      return this.scroller.needsXScrolling();\n    }\n  }, {\n    key: \"needsYScrolling\",\n    value: function needsYScrolling() {\n      return this.scroller.needsYScrolling();\n    }\n  }]);\n  return ClippedScroller;\n}(BaseComponent);\nvar WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nvar ScrollListener = /*#__PURE__*/function () {\n  function ScrollListener(el) {\n    var _this3 = this;\n    _classCallCheck(this, ScrollListener);\n    this.el = el;\n    this.emitter = new Emitter();\n    this.isScrolling = false;\n    this.isTouching = false; // user currently has finger down?\n    this.isRecentlyWheeled = false;\n    this.isRecentlyScrolled = false;\n    this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n    this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n    // Handlers\n    // ----------------------------------------------------------------------------------------------\n    this.handleScroll = function () {\n      _this3.startScroll();\n      _this3.emitter.trigger('scroll', _this3.isRecentlyWheeled, _this3.isTouching);\n      _this3.isRecentlyScrolled = true;\n      _this3.scrollWaiter.request(500);\n    };\n    // will fire *before* the scroll event is fired (might not cause a scroll)\n    this.handleWheel = function () {\n      _this3.isRecentlyWheeled = true;\n      _this3.wheelWaiter.request(500);\n    };\n    // will fire *before* the scroll event is fired (might not cause a scroll)\n    this.handleTouchStart = function () {\n      _this3.isTouching = true;\n    };\n    this.handleTouchEnd = function () {\n      _this3.isTouching = false;\n      // if the user ended their touch, and the scroll area wasn't moving,\n      // we consider this to be the end of the scroll.\n      if (!_this3.isRecentlyScrolled) {\n        _this3.endScroll(); // won't fire if already ended\n      }\n    };\n\n    el.addEventListener('scroll', this.handleScroll);\n    el.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.addEventListener('touchend', this.handleTouchEnd);\n    var _iterator2 = _createForOfIteratorHelper(WHEEL_EVENT_NAMES),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var eventName = _step2.value;\n        el.addEventListener(eventName, this.handleWheel);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  _createClass(ScrollListener, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var el = this.el;\n      el.removeEventListener('scroll', this.handleScroll);\n      el.removeEventListener('touchstart', this.handleTouchStart, {\n        passive: true\n      });\n      el.removeEventListener('touchend', this.handleTouchEnd);\n      var _iterator3 = _createForOfIteratorHelper(WHEEL_EVENT_NAMES),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var eventName = _step3.value;\n          el.removeEventListener(eventName, this.handleWheel);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    // Start / Stop\n    // ----------------------------------------------------------------------------------------------\n  }, {\n    key: \"startScroll\",\n    value: function startScroll() {\n      if (!this.isScrolling) {\n        this.isScrolling = true;\n        this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n      }\n    }\n  }, {\n    key: \"endScroll\",\n    value: function endScroll() {\n      if (this.isScrolling) {\n        this.emitter.trigger('scrollEnd');\n        this.isScrolling = false;\n        this.isRecentlyScrolled = true;\n        this.isRecentlyWheeled = false;\n        this.scrollWaiter.clear();\n        this.wheelWaiter.clear();\n      }\n    }\n  }, {\n    key: \"_handleScrollWaited\",\n    value: function _handleScrollWaited() {\n      this.isRecentlyScrolled = false;\n      // only end the scroll if not currently touching.\n      // if touching, the scrolling will end later, on touchend.\n      if (!this.isTouching) {\n        this.endScroll(); // won't fire if already ended\n      }\n    }\n  }, {\n    key: \"_handleWheelWaited\",\n    value: function _handleWheelWaited() {\n      this.isRecentlyWheeled = false;\n    }\n  }]);\n  return ScrollListener;\n}();\nvar ScrollSyncer = /*#__PURE__*/function () {\n  function ScrollSyncer(isVertical, scrollEls) {\n    var _this4 = this;\n    _classCallCheck(this, ScrollSyncer);\n    this.isVertical = isVertical;\n    this.scrollEls = scrollEls;\n    this.isPaused = false;\n    this.scrollListeners = scrollEls.map(function (el) {\n      return _this4.bindScroller(el);\n    });\n  }\n  _createClass(ScrollSyncer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator4 = _createForOfIteratorHelper(this.scrollListeners),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var scrollListener = _step4.value;\n          scrollListener.destroy();\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"bindScroller\",\n    value: function bindScroller(el) {\n      var _this5 = this;\n      var scrollEls = this.scrollEls,\n        isVertical = this.isVertical;\n      var scrollListener = new ScrollListener(el);\n      var onScroll = function onScroll(isWheel, isTouch) {\n        if (!_this5.isPaused) {\n          if (!_this5.masterEl || _this5.masterEl !== el && (isWheel || isTouch)) {\n            _this5.assignMaster(el);\n          }\n          if (_this5.masterEl === el) {\n            // dealing with current\n            var _iterator5 = _createForOfIteratorHelper(scrollEls),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var otherEl = _step5.value;\n                if (otherEl !== el) {\n                  if (isVertical) {\n                    otherEl.scrollTop = el.scrollTop;\n                  } else {\n                    otherEl.scrollLeft = el.scrollLeft;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        }\n      };\n      var onScrollEnd = function onScrollEnd() {\n        if (_this5.masterEl === el) {\n          _this5.masterEl = null;\n        }\n      };\n      scrollListener.emitter.on('scroll', onScroll);\n      scrollListener.emitter.on('scrollEnd', onScrollEnd);\n      return scrollListener;\n    }\n  }, {\n    key: \"assignMaster\",\n    value: function assignMaster(el) {\n      this.masterEl = el;\n      var _iterator6 = _createForOfIteratorHelper(this.scrollListeners),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var scrollListener = _step6.value;\n          if (scrollListener.el !== el) {\n            scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /*\n    will normalize the scrollLeft value\n    */\n  }, {\n    key: \"forceScrollLeft\",\n    value: function forceScrollLeft(scrollLeft) {\n      this.isPaused = true;\n      var _iterator7 = _createForOfIteratorHelper(this.scrollListeners),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var listener = _step7.value;\n          setScrollFromLeftEdge(listener.el, scrollLeft);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      this.isPaused = false;\n    }\n  }, {\n    key: \"forceScrollTop\",\n    value: function forceScrollTop(top) {\n      this.isPaused = true;\n      var _iterator8 = _createForOfIteratorHelper(this.scrollListeners),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var listener = _step8.value;\n          listener.el.scrollTop = top;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      this.isPaused = false;\n    }\n  }]);\n  return ScrollSyncer;\n}();\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nvar ScrollGrid = /*#__PURE__*/function (_BaseComponent2) {\n  _inherits(ScrollGrid, _BaseComponent2);\n  var _super2 = _createSuper(ScrollGrid);\n  function ScrollGrid() {\n    var _this6;\n    _classCallCheck(this, ScrollGrid);\n    _this6 = _super2.apply(this, arguments);\n    _this6.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n    _this6.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n    _this6.clippedScrollerRefs = new RefMap();\n    // doesn't hold non-scrolling els used just for padding\n    _this6.scrollerElRefs = new RefMap(_this6._handleScrollerEl.bind(_assertThisInitialized(_this6)));\n    _this6.chunkElRefs = new RefMap(_this6._handleChunkEl.bind(_assertThisInitialized(_this6)));\n    _this6.scrollSyncersBySection = {};\n    _this6.scrollSyncersByColumn = {};\n    // for row-height-syncing\n    _this6.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n    _this6.rowInnerMaxHeightMap = new Map();\n    _this6.anyRowHeightsChanged = false;\n    _this6.recentSizingCnt = 0;\n    _this6.state = {\n      shrinkWidths: [],\n      forceYScrollbars: false,\n      forceXScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {},\n      sectionRowMaxHeights: []\n    };\n    _this6.handleSizing = function (isForcedResize, sectionRowMaxHeightsChanged) {\n      if (!_this6.allowSizing()) {\n        return;\n      }\n      if (!sectionRowMaxHeightsChanged) {\n        // something else changed, probably external\n        _this6.anyRowHeightsChanged = true;\n      }\n      var otherState = {};\n      // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n      if (isForcedResize || !sectionRowMaxHeightsChanged && !_this6.rowUnstableMap.size) {\n        otherState.sectionRowMaxHeights = _this6.computeSectionRowMaxHeights();\n      }\n      _this6.setState(Object.assign(Object.assign({\n        shrinkWidths: _this6.computeShrinkWidths()\n      }, _this6.computeScrollerDims()), otherState), function () {\n        if (!_this6.rowUnstableMap.size) {\n          _this6.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n        }\n      });\n    };\n\n    _this6.handleRowHeightChange = function (rowEl, isStable) {\n      var _assertThisInitialize2 = _assertThisInitialized(_this6),\n        rowUnstableMap = _assertThisInitialize2.rowUnstableMap,\n        rowInnerMaxHeightMap = _assertThisInitialize2.rowInnerMaxHeightMap;\n      if (!isStable) {\n        rowUnstableMap.set(rowEl, true);\n      } else {\n        rowUnstableMap.delete(rowEl);\n        var innerMaxHeight = getRowInnerMaxHeight(rowEl);\n        if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n          rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n          _this6.anyRowHeightsChanged = true;\n        }\n        if (!rowUnstableMap.size && _this6.anyRowHeightsChanged) {\n          _this6.anyRowHeightsChanged = false;\n          _this6.setState({\n            sectionRowMaxHeights: _this6.computeSectionRowMaxHeights()\n          });\n        }\n      }\n    };\n    return _this6;\n  }\n  _createClass(ScrollGrid, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        state = this.state,\n        context = this.context;\n      var shrinkWidths = state.shrinkWidths;\n      var colGroupStats = this.compileColGroupStats(props.colGroups.map(function (colGroup) {\n        return [colGroup];\n      }));\n      var microColGroupNodes = this.renderMicroColGroups(colGroupStats.map(function (stat, i) {\n        return [stat.cols, shrinkWidths[i]];\n      }));\n      var classNames = getScrollGridClassNames(props.liquid, context);\n      this.getDims();\n      // TODO: make DRY\n      var sectionConfigs = props.sections;\n      var configCnt = sectionConfigs.length;\n      var configI = 0;\n      var currentConfig;\n      var headSectionNodes = [];\n      var bodySectionNodes = [];\n      var footSectionNodes = [];\n      while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n        headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n        configI += 1;\n      }\n      while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n        bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n        configI += 1;\n      }\n      while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n        footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n        configI += 1;\n      }\n      var isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n      var roleAttrs = {\n        role: 'rowgroup'\n      };\n      return createElement('table', {\n        ref: props.elRef,\n        role: 'grid',\n        className: classNames.join(' ')\n      }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement.apply(void 0, ['thead', roleAttrs].concat(headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && createElement.apply(void 0, ['tbody', roleAttrs].concat(bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && createElement.apply(void 0, ['tfoot', roleAttrs].concat(footSectionNodes)), isBuggy && createElement.apply(void 0, ['tbody', roleAttrs].concat(headSectionNodes, bodySectionNodes, footSectionNodes)));\n    }\n  }, {\n    key: \"renderSection\",\n    value: function renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n      var _this7 = this;\n      if ('outerContent' in sectionConfig) {\n        return createElement(Fragment, {\n          key: sectionConfig.key\n        }, sectionConfig.outerContent);\n      }\n      return createElement(\"tr\", {\n        key: sectionConfig.key,\n        role: \"presentation\",\n        className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n      }, sectionConfig.chunks.map(function (chunkConfig, i) {\n        return _this7.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader);\n      }));\n    }\n  }, {\n    key: \"renderChunk\",\n    value: function renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n      if ('outerContent' in chunkConfig) {\n        return createElement(Fragment, {\n          key: chunkConfig.key\n        }, chunkConfig.outerContent);\n      }\n      var state = this.state;\n      var scrollerClientWidths = state.scrollerClientWidths,\n        scrollerClientHeights = state.scrollerClientHeights;\n      var _this$getDims = this.getDims(),\n        _this$getDims2 = _slicedToArray(_this$getDims, 2),\n        sectionCnt = _this$getDims2[0],\n        chunksPerSection = _this$getDims2[1];\n      var index = sectionIndex * chunksPerSection + chunkIndex;\n      var sideScrollIndex = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n      var isVScrollSide = chunkIndex === sideScrollIndex;\n      var isLastSection = sectionIndex === sectionCnt - 1;\n      var forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n      var forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n      var allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n      var allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n      var chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n      var expandRows = sectionConfig.expandRows && chunkVGrow;\n      var tableMinWidth = colGroupStat && colGroupStat.totalColMinWidth || '';\n      var content = renderChunkContent(sectionConfig, chunkConfig, {\n        tableColGroupNode: microColGroupNode,\n        tableMinWidth: tableMinWidth,\n        clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n        clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n        expandRows: expandRows,\n        syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n        rowSyncHeights: rowHeights,\n        reportRowHeightChange: this.handleRowHeightChange\n      }, isHeader);\n      var overflowX = forceXScrollbars ? isLastSection ? 'scroll' : 'scroll-hidden' : !allowXScrolling ? 'hidden' : isLastSection ? 'auto' : 'scroll-hidden';\n      var overflowY = forceYScrollbars ? isVScrollSide ? 'scroll' : 'scroll-hidden' : !allowYScrolling ? 'hidden' : isVScrollSide ? 'auto' : 'scroll-hidden';\n      // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n      // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n      content = createElement(ClippedScroller, {\n        ref: this.clippedScrollerRefs.createRef(index),\n        scrollerElRef: this.scrollerElRefs.createRef(index),\n        overflowX: overflowX,\n        overflowY: overflowY,\n        forPrint: this.props.forPrint,\n        liquid: chunkVGrow,\n        maxHeight: sectionConfig.maxHeight\n      }, content);\n      return createElement(isHeader ? 'th' : 'td', {\n        key: chunkConfig.key,\n        ref: this.chunkElRefs.createRef(index),\n        role: 'presentation'\n      }, content);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n      this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n      this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n      this.updateScrollSyncers();\n      this.handleSizing(false);\n      this.context.addResizeHandler(this.handleSizing);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      this.updateScrollSyncers();\n      // TODO: need better solution when state contains non-sizing things\n      this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.context.removeResizeHandler(this.handleSizing);\n      this.destroyScrollSyncers();\n    }\n  }, {\n    key: \"allowSizing\",\n    value: function allowSizing() {\n      var now = new Date();\n      if (!this.lastSizingDate || now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n        this.lastSizingDate = now;\n        this.recentSizingCnt = 0;\n        return true;\n      }\n      return (this.recentSizingCnt += 1) <= 10;\n    }\n  }, {\n    key: \"computeShrinkWidths\",\n    value: function computeShrinkWidths() {\n      var _this8 = this;\n      var colGroupStats = this.compileColGroupStats(this.props.colGroups.map(function (colGroup) {\n        return [colGroup];\n      }));\n      var _this$getDims3 = this.getDims(),\n        _this$getDims4 = _slicedToArray(_this$getDims3, 2),\n        sectionCnt = _this$getDims4[0],\n        chunksPerSection = _this$getDims4[1];\n      var cnt = sectionCnt * chunksPerSection;\n      var shrinkWidths = [];\n      colGroupStats.forEach(function (colGroupStat, i) {\n        if (colGroupStat.hasShrinkCol) {\n          var chunkEls = _this8.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n          shrinkWidths[i] = computeShrinkWidth(chunkEls);\n        }\n      });\n      return shrinkWidths;\n    }\n    // has the side effect of grooming rowInnerMaxHeightMap\n    // TODO: somehow short-circuit if there are no new height changes\n  }, {\n    key: \"computeSectionRowMaxHeights\",\n    value: function computeSectionRowMaxHeights() {\n      var newHeightMap = new Map();\n      var _this$getDims5 = this.getDims(),\n        _this$getDims6 = _slicedToArray(_this$getDims5, 2),\n        sectionCnt = _this$getDims6[0],\n        chunksPerSection = _this$getDims6[1];\n      var sectionRowMaxHeights = [];\n      for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n        var sectionConfig = this.props.sections[sectionI];\n        var assignableHeights = []; // chunk, row\n        if (sectionConfig && sectionConfig.syncRowHeights) {\n          var rowHeightsByChunk = [];\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            var index = sectionI * chunksPerSection + chunkI;\n            var rowHeights = [];\n            var chunkEl = this.chunkElRefs.currentMap[index];\n            if (chunkEl) {\n              rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map(function (rowEl) {\n                var max = getRowInnerMaxHeight(rowEl);\n                newHeightMap.set(rowEl, max);\n                return max;\n              });\n            } else {\n              rowHeights = [];\n            }\n            rowHeightsByChunk.push(rowHeights);\n          }\n          var rowCnt = rowHeightsByChunk[0].length;\n          var isEqualRowCnt = true;\n          for (var _chunkI = 1; _chunkI < chunksPerSection; _chunkI += 1) {\n            var isOuterContent = sectionConfig.chunks[_chunkI] && sectionConfig.chunks[_chunkI].outerContent !== undefined; // can be null\n            if (!isOuterContent && rowHeightsByChunk[_chunkI].length !== rowCnt) {\n              // skip outer content\n              isEqualRowCnt = false;\n              break;\n            }\n          }\n          if (!isEqualRowCnt) {\n            var chunkHeightSums = [];\n            for (var _chunkI2 = 0; _chunkI2 < chunksPerSection; _chunkI2 += 1) {\n              chunkHeightSums.push(sumNumbers(rowHeightsByChunk[_chunkI2]) + rowHeightsByChunk[_chunkI2].length);\n            }\n            var maxTotalSum = Math.max.apply(Math, chunkHeightSums);\n            for (var _chunkI3 = 0; _chunkI3 < chunksPerSection; _chunkI3 += 1) {\n              var rowInChunkCnt = rowHeightsByChunk[_chunkI3].length;\n              var rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n              // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n              var rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n              // whatever is leftover goes to the first row\n              var rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n              var rowInChunkHeights = [];\n              var row = 0;\n              if (row < rowInChunkCnt) {\n                rowInChunkHeights.push(rowInChunkHeightFirst);\n                row += 1;\n              }\n              while (row < rowInChunkCnt) {\n                rowInChunkHeights.push(rowInChunkHeightOthers);\n                row += 1;\n              }\n              assignableHeights.push(rowInChunkHeights);\n            }\n          } else {\n            for (var _chunkI4 = 0; _chunkI4 < chunksPerSection; _chunkI4 += 1) {\n              assignableHeights.push([]);\n            }\n            for (var _row = 0; _row < rowCnt; _row += 1) {\n              var rowHeightsAcrossChunks = [];\n              for (var _chunkI5 = 0; _chunkI5 < chunksPerSection; _chunkI5 += 1) {\n                var h = rowHeightsByChunk[_chunkI5][_row];\n                if (h != null) {\n                  // protect against outerContent\n                  rowHeightsAcrossChunks.push(h);\n                }\n              }\n              var maxHeight = Math.max.apply(Math, rowHeightsAcrossChunks);\n              for (var _chunkI6 = 0; _chunkI6 < chunksPerSection; _chunkI6 += 1) {\n                assignableHeights[_chunkI6].push(maxHeight);\n              }\n            }\n          }\n        }\n        sectionRowMaxHeights.push(assignableHeights);\n      }\n      this.rowInnerMaxHeightMap = newHeightMap;\n      return sectionRowMaxHeights;\n    }\n  }, {\n    key: \"computeScrollerDims\",\n    value: function computeScrollerDims() {\n      var scrollbarWidth = getScrollbarWidths();\n      var _this$getDims7 = this.getDims(),\n        _this$getDims8 = _slicedToArray(_this$getDims7, 2),\n        sectionCnt = _this$getDims8[0],\n        chunksPerSection = _this$getDims8[1];\n      var sideScrollI = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n      var lastSectionI = sectionCnt - 1;\n      var currentScrollers = this.clippedScrollerRefs.currentMap;\n      var scrollerEls = this.scrollerElRefs.currentMap;\n      var forceYScrollbars = false;\n      var forceXScrollbars = false;\n      var scrollerClientWidths = {};\n      var scrollerClientHeights = {};\n      for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n        // along edge\n        var index = sectionI * chunksPerSection + sideScrollI;\n        var scroller = currentScrollers[index];\n        if (scroller && scroller.needsYScrolling()) {\n          forceYScrollbars = true;\n          break;\n        }\n      }\n      for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        // along last row\n        var _index = lastSectionI * chunksPerSection + chunkI;\n        var _scroller = currentScrollers[_index];\n        if (_scroller && _scroller.needsXScrolling()) {\n          forceXScrollbars = true;\n          break;\n        }\n      }\n      for (var _sectionI = 0; _sectionI < sectionCnt; _sectionI += 1) {\n        for (var _chunkI7 = 0; _chunkI7 < chunksPerSection; _chunkI7 += 1) {\n          var _index2 = _sectionI * chunksPerSection + _chunkI7;\n          var scrollerEl = scrollerEls[_index2];\n          if (scrollerEl) {\n            // TODO: weird way to get this. need harness b/c doesn't include table borders\n            var harnessEl = scrollerEl.parentNode;\n            scrollerClientWidths[_index2] = Math.floor(harnessEl.getBoundingClientRect().width - (_chunkI7 === sideScrollI && forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n            : 0));\n            scrollerClientHeights[_index2] = Math.floor(harnessEl.getBoundingClientRect().height - (_sectionI === lastSectionI && forceXScrollbars ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n            : 0));\n          }\n        }\n      }\n      return {\n        forceYScrollbars: forceYScrollbars,\n        forceXScrollbars: forceXScrollbars,\n        scrollerClientWidths: scrollerClientWidths,\n        scrollerClientHeights: scrollerClientHeights\n      };\n    }\n  }, {\n    key: \"updateStickyScrolling\",\n    value: function updateStickyScrolling() {\n      var isRtl = this.context.isRtl;\n      var argsByKey = this.scrollerElRefs.getAll().map(function (scrollEl) {\n        return [scrollEl, isRtl];\n      });\n      this.getStickyScrolling(argsByKey).forEach(function (stickyScrolling) {\n        return stickyScrolling.updateSize();\n      });\n    }\n  }, {\n    key: \"updateScrollSyncers\",\n    value: function updateScrollSyncers() {\n      var _this$getDims9 = this.getDims(),\n        _this$getDims10 = _slicedToArray(_this$getDims9, 2),\n        sectionCnt = _this$getDims10[0],\n        chunksPerSection = _this$getDims10[1];\n      var cnt = sectionCnt * chunksPerSection;\n      var scrollElsBySection = {};\n      var scrollElsByColumn = {};\n      var scrollElMap = this.scrollerElRefs.currentMap;\n      for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n        var startIndex = sectionI * chunksPerSection;\n        var endIndex = startIndex + chunksPerSection;\n        scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n      }\n\n      for (var col = 0; col < chunksPerSection; col += 1) {\n        scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n      }\n\n      this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n      this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n    }\n  }, {\n    key: \"destroyScrollSyncers\",\n    value: function destroyScrollSyncers() {\n      mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n      mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n    }\n  }, {\n    key: \"getChunkConfigByIndex\",\n    value: function getChunkConfigByIndex(index) {\n      var chunksPerSection = this.getDims()[1];\n      var sectionI = Math.floor(index / chunksPerSection);\n      var chunkI = index % chunksPerSection;\n      var sectionConfig = this.props.sections[sectionI];\n      return sectionConfig && sectionConfig.chunks[chunkI];\n    }\n  }, {\n    key: \"forceScrollLeft\",\n    value: function forceScrollLeft(col, scrollLeft) {\n      var scrollSyncer = this.scrollSyncersByColumn[col];\n      if (scrollSyncer) {\n        scrollSyncer.forceScrollLeft(scrollLeft);\n      }\n    }\n  }, {\n    key: \"forceScrollTop\",\n    value: function forceScrollTop(sectionI, scrollTop) {\n      var scrollSyncer = this.scrollSyncersBySection[sectionI];\n      if (scrollSyncer) {\n        scrollSyncer.forceScrollTop(scrollTop);\n      }\n    }\n  }, {\n    key: \"_handleChunkEl\",\n    value: function _handleChunkEl(chunkEl, key) {\n      var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n      if (chunkConfig) {\n        // null if section disappeared. bad, b/c won't null-set the elRef\n        setRef(chunkConfig.elRef, chunkEl);\n      }\n    }\n  }, {\n    key: \"_handleScrollerEl\",\n    value: function _handleScrollerEl(scrollerEl, key) {\n      var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n      if (chunkConfig) {\n        // null if section disappeared. bad, b/c won't null-set the elRef\n        setRef(chunkConfig.scrollerElRef, scrollerEl);\n      }\n    }\n  }, {\n    key: \"getDims\",\n    value: function getDims() {\n      var sectionCnt = this.props.sections.length;\n      var chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n      return [sectionCnt, chunksPerSection];\n    }\n  }]);\n  return ScrollGrid;\n}(BaseComponent);\nScrollGrid.addStateEquality({\n  shrinkWidths: isArraysEqual,\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\nfunction sumNumbers(numbers) {\n  var sum = 0;\n  var _iterator9 = _createForOfIteratorHelper(numbers),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var n = _step9.value;\n      sum += n;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n  var innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n  if (innerHeights.length) {\n    return Math.max.apply(Math, _toConsumableArray(innerHeights));\n  }\n  return 0;\n}\nfunction getElHeight(el) {\n  return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\n\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n  var children = colGroupStats.map(function (colGroupStat, i) {\n    var width = colGroupStat.width;\n    if (width === 'shrink') {\n      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n    }\n\n    return (\n      // eslint-disable-next-line react/jsx-key\n      createElement(\"col\", {\n        style: {\n          width: width\n        }\n      })\n    );\n  });\n  return createElement.apply(void 0, ['colgroup', {}].concat(_toConsumableArray(children)));\n}\nfunction compileColGroupStat(colGroupConfig) {\n  var totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n  var totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n  var hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n  var allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n  return {\n    hasShrinkCol: hasShrinkCol,\n    totalColWidth: totalColWidth,\n    totalColMinWidth: totalColMinWidth,\n    allowXScrolling: allowXScrolling,\n    cols: colGroupConfig.cols,\n    width: colGroupConfig.width\n  };\n}\nfunction sumColProp(cols, propName) {\n  var total = 0;\n  var _iterator10 = _createForOfIteratorHelper(cols),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var col = _step10.value;\n      var val = col[propName];\n      if (typeof val === 'number') {\n        total += val * (col.span || 1);\n      }\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return total;\n}\nvar COL_GROUP_STAT_EQUALITY = {\n  cols: isColPropsEqual\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical) {\n  for (var _len = arguments.length, scrollEls = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    scrollEls[_key - 1] = arguments[_key];\n  }\n  return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n  scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n  return new StickyScrolling(scrollEl, isRtl);\n}\nexport { ScrollGrid };","map":{"version":3,"names":["computeEdges","removeElement","findElements","translateRect","computeInnerRect","applyStyle","BaseComponent","setRef","getIsRtlScrollbarOnLeft","Scroller","isPropsEqual","Emitter","DelayedRunner","config","memoizeArraylike","renderMicroColGroup","RefMap","getScrollGridClassNames","getCanVGrowWithinCell","getSectionClassNames","getAllowYScrolling","getSectionHasLiquidHeight","renderChunkContent","memoizeHashlike","computeShrinkWidth","getScrollbarWidths","collectFromHash","mapHash","isArraysEqual","sanitizeShrinkWidth","hasShrinkWidth","compareObjs","isColPropsEqual","createRef","createElement","Fragment","getScrollCanvasOrigin","scrollEl","rect","getBoundingClientRect","edges","left","borderLeft","scrollbarLeft","getScrollFromLeftEdge","top","borderTop","scrollTop","el","scrollLeft","computedStyles","window","getComputedStyle","direction","getRtlScrollSystem","scrollWidth","clientWidth","setScrollFromLeftEdge","_rtlScrollSystem","detectRtlScrollSystem","document","style","position","width","height","overflow","innerEl","appendChild","body","system","STICKY_SELECTOR","StickyScrolling","isRtl","_this","_classCallCheck","updateSize","els","elGeoms","queryElGeoms","viewportWidth","assignStickyPositions","_createClass","key","value","canvasOrigin","_iterator","_createForOfIteratorHelper","_step","s","n","done","parentBound","parentNode","elRect","textAlign","naturalBound","parseFloat","push","elWidth","elHeight","err","e","f","forEach","i","_elGeoms$i","parentWidth","right","ClippedScroller","_BaseComponent","_inherits","_super","_createSuper","_this2","apply","arguments","elRef","state","xScrollbarWidth","yScrollbarWidth","handleScroller","scroller","props","scrollerRef","handleSizing","_assertThisInitialize","_assertThisInitialized","overflowY","setState","getYScrollbarWidth","overflowX","getXScrollbarWidth","render","context","isScrollbarOnLeft","overcomeLeft","overcomeRight","overcomeBottom","forPrint","ref","className","liquid","scrollerElRef","maxHeight","liquidIsAbsolute","children","componentDidMount","addResizeHandler","getSnapshotBeforeUpdate","prevProps","simulateScrollLeft","componentDidUpdate","prevState","snapshot","scrollerEl","undefined","restoredScrollLeft","parseInt","componentWillUnmount","removeResizeHandler","needsXScrolling","needsYScrolling","WHEEL_EVENT_NAMES","split","ScrollListener","_this3","emitter","isScrolling","isTouching","isRecentlyWheeled","isRecentlyScrolled","wheelWaiter","_handleWheelWaited","bind","scrollWaiter","_handleScrollWaited","handleScroll","startScroll","trigger","request","handleWheel","handleTouchStart","handleTouchEnd","endScroll","addEventListener","passive","_iterator2","_step2","eventName","destroy","removeEventListener","_iterator3","_step3","clear","ScrollSyncer","isVertical","scrollEls","_this4","isPaused","scrollListeners","map","bindScroller","_iterator4","_step4","scrollListener","_this5","onScroll","isWheel","isTouch","masterEl","assignMaster","_iterator5","_step5","otherEl","onScrollEnd","on","_iterator6","_step6","forceScrollLeft","_iterator7","_step7","listener","forceScrollTop","_iterator8","_step8","SCROLLGRID_RESIZE_INTERVAL","ScrollGrid","_BaseComponent2","_super2","_this6","compileColGroupStats","compileColGroupStat","isColGroupStatsEqual","renderMicroColGroups","clippedScrollerRefs","scrollerElRefs","_handleScrollerEl","chunkElRefs","_handleChunkEl","scrollSyncersBySection","scrollSyncersByColumn","rowUnstableMap","Map","rowInnerMaxHeightMap","anyRowHeightsChanged","recentSizingCnt","shrinkWidths","forceYScrollbars","forceXScrollbars","scrollerClientWidths","scrollerClientHeights","sectionRowMaxHeights","isForcedResize","sectionRowMaxHeightsChanged","allowSizing","otherState","size","computeSectionRowMaxHeights","Object","assign","computeShrinkWidths","computeScrollerDims","updateStickyScrolling","handleRowHeightChange","rowEl","isStable","_assertThisInitialize2","set","delete","innerMaxHeight","getRowInnerMaxHeight","has","get","colGroupStats","colGroups","colGroup","microColGroupNodes","stat","cols","classNames","getDims","sectionConfigs","sections","configCnt","length","configI","currentConfig","headSectionNodes","bodySectionNodes","footSectionNodes","type","renderSection","isBuggy","roleAttrs","role","join","renderMacroColGroup","Boolean","concat","sectionConfig","sectionIndex","isHeader","_this7","outerContent","chunks","chunkConfig","renderChunk","colGroupStat","microColGroupNode","chunkIndex","rowHeights","_this$getDims","_this$getDims2","_slicedToArray","sectionCnt","chunksPerSection","index","sideScrollIndex","isVScrollSide","isLastSection","allowXScrolling","allowYScrolling","chunkVGrow","expandRows","tableMinWidth","totalColMinWidth","content","tableColGroupNode","clientHeight","syncRowHeights","rowSyncHeights","reportRowHeightChange","getStickyScrolling","initStickyScrolling","getScrollSyncersBySection","initScrollSyncer","destroyScrollSyncer","getScrollSyncersByColumn","updateScrollSyncers","destroyScrollSyncers","now","Date","lastSizingDate","valueOf","_this8","_this$getDims3","_this$getDims4","cnt","hasShrinkCol","chunkEls","collect","newHeightMap","_this$getDims5","_this$getDims6","sectionI","assignableHeights","rowHeightsByChunk","chunkI","chunkEl","currentMap","max","rowCnt","isEqualRowCnt","isOuterContent","chunkHeightSums","sumNumbers","maxTotalSum","Math","rowInChunkCnt","rowInChunkTotalHeight","rowInChunkHeightOthers","floor","rowInChunkHeightFirst","rowInChunkHeights","row","rowHeightsAcrossChunks","h","scrollbarWidth","_this$getDims7","_this$getDims8","sideScrollI","lastSectionI","currentScrollers","scrollerEls","harnessEl","y","x","argsByKey","getAll","stickyScrolling","_this$getDims9","_this$getDims10","scrollElsBySection","scrollElsByColumn","scrollElMap","startIndex","endIndex","col","getChunkConfigByIndex","scrollSyncer","addStateEquality","numbers","sum","_iterator9","_step9","innerHeights","getElHeight","_toConsumableArray","offsetHeight","totalColWidth","colGroupConfig","sumColProp","propName","total","_iterator10","_step10","val","span","COL_GROUP_STAT_EQUALITY","stat0","stat1","_len","Array","_key"],"sources":["C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@fullcalendar/scrollgrid/internal.js"],"sourcesContent":["import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n    let rect = scrollEl.getBoundingClientRect();\n    let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n    return {\n        left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n        top: rect.top + edges.borderTop - scrollEl.scrollTop,\n    };\n}\nfunction getScrollFromLeftEdge(el) {\n    let scrollLeft = el.scrollLeft;\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'negative':\n                scrollLeft *= -1; // convert to 'reverse'. fall through...\n            case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n                scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n        }\n    }\n    return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'reverse':\n                scrollLeft = el.scrollWidth - scrollLeft;\n                break;\n            case 'negative':\n                scrollLeft = -(el.scrollWidth - scrollLeft);\n                break;\n        }\n    }\n    el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nlet _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n    let el = document.createElement('div');\n    el.style.position = 'absolute';\n    el.style.top = '-1000px';\n    el.style.width = '100px'; // must be at least the side of scrollbars or you get inaccurate values (#7335)\n    el.style.height = '100px'; // \"\n    el.style.overflow = 'scroll';\n    el.style.direction = 'rtl';\n    let innerEl = document.createElement('div');\n    innerEl.style.width = '200px';\n    innerEl.style.height = '200px';\n    el.appendChild(innerEl);\n    document.body.appendChild(el);\n    let system;\n    if (el.scrollLeft > 0) {\n        system = 'positive'; // scroll is a positive number from the left edge\n    }\n    else {\n        el.scrollLeft = 1;\n        if (el.scrollLeft > 0) {\n            system = 'reverse'; // scroll is a positive number from the right edge\n        }\n        else {\n            system = 'negative'; // scroll is a negative number from the right edge\n        }\n    }\n    removeElement(el);\n    return system;\n}\n\nconst STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nclass StickyScrolling {\n    constructor(scrollEl, isRtl) {\n        this.scrollEl = scrollEl;\n        this.isRtl = isRtl;\n        this.updateSize = () => {\n            let { scrollEl } = this;\n            let els = findElements(scrollEl, STICKY_SELECTOR);\n            let elGeoms = this.queryElGeoms(els);\n            let viewportWidth = scrollEl.clientWidth;\n            assignStickyPositions(els, elGeoms, viewportWidth);\n        };\n    }\n    queryElGeoms(els) {\n        let { scrollEl, isRtl } = this;\n        let canvasOrigin = getScrollCanvasOrigin(scrollEl);\n        let elGeoms = [];\n        for (let el of els) {\n            let parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n            -canvasOrigin.left, -canvasOrigin.top);\n            let elRect = el.getBoundingClientRect();\n            let computedStyles = window.getComputedStyle(el);\n            let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n            let naturalBound = null;\n            if (textAlign === 'start') {\n                textAlign = isRtl ? 'right' : 'left';\n            }\n            else if (textAlign === 'end') {\n                textAlign = isRtl ? 'left' : 'right';\n            }\n            if (computedStyles.position !== 'sticky') {\n                naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n                -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n            }\n            elGeoms.push({\n                parentBound,\n                naturalBound,\n                elWidth: elRect.width,\n                elHeight: elRect.height,\n                textAlign,\n            });\n        }\n        return elGeoms;\n    }\n}\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n    els.forEach((el, i) => {\n        let { textAlign, elWidth, parentBound } = elGeoms[i];\n        let parentWidth = parentBound.right - parentBound.left;\n        let left;\n        if (textAlign === 'center' &&\n            parentWidth > viewportWidth) {\n            left = (viewportWidth - elWidth) / 2;\n        }\n        else { // if parent container can be completely in view, we don't need stickiness\n            left = '';\n        }\n        applyStyle(el, {\n            left,\n            right: left,\n            top: 0,\n        });\n    });\n}\n\nclass ClippedScroller extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.elRef = createRef();\n        this.state = {\n            xScrollbarWidth: 0,\n            yScrollbarWidth: 0,\n        };\n        this.handleScroller = (scroller) => {\n            this.scroller = scroller;\n            setRef(this.props.scrollerRef, scroller);\n        };\n        this.handleSizing = () => {\n            let { props } = this;\n            if (props.overflowY === 'scroll-hidden') {\n                this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });\n            }\n            if (props.overflowX === 'scroll-hidden') {\n                this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n        let overcomeLeft = 0;\n        let overcomeRight = 0;\n        let overcomeBottom = 0;\n        let { overflowX, overflowY } = props;\n        if (props.forPrint) {\n            overflowX = 'visible';\n            overflowY = 'visible';\n        }\n        if (overflowX === 'scroll-hidden') {\n            overcomeBottom = state.xScrollbarWidth;\n        }\n        if (overflowY === 'scroll-hidden') {\n            if (state.yScrollbarWidth != null) {\n                if (isScrollbarOnLeft) {\n                    overcomeLeft = state.yScrollbarWidth;\n                }\n                else {\n                    overcomeRight = state.yScrollbarWidth;\n                }\n            }\n        }\n        return (createElement(\"div\", { ref: this.elRef, className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '') },\n            createElement(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX, overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY, overcomeLeft: overcomeLeft, overcomeRight: overcomeRight, overcomeBottom: overcomeBottom, maxHeight: typeof props.maxHeight === 'number'\n                    ? (props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n                    : '', liquid: props.liquid, liquidIsAbsolute: true }, props.children)));\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        if (this.props.forPrint && !prevProps.forPrint) {\n            return { simulateScrollLeft: this.scroller.el.scrollLeft };\n        }\n        return {};\n    }\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        const { props, scroller: { el: scrollerEl } } = this;\n        if (!isPropsEqual(prevProps, props)) { // an external change?\n            this.handleSizing();\n        }\n        if (snapshot.simulateScrollLeft !== undefined) {\n            scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n        }\n        else if (!props.forPrint && prevProps.forPrint) {\n            const restoredScrollLeft = -parseInt(scrollerEl.style.left);\n            scrollerEl.style.left = '';\n            scrollerEl.scrollLeft = restoredScrollLeft;\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    needsXScrolling() {\n        return this.scroller.needsXScrolling();\n    }\n    needsYScrolling() {\n        return this.scroller.needsYScrolling();\n    }\n}\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nclass ScrollListener {\n    constructor(el) {\n        this.el = el;\n        this.emitter = new Emitter();\n        this.isScrolling = false;\n        this.isTouching = false; // user currently has finger down?\n        this.isRecentlyWheeled = false;\n        this.isRecentlyScrolled = false;\n        this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n        this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n        // Handlers\n        // ----------------------------------------------------------------------------------------------\n        this.handleScroll = () => {\n            this.startScroll();\n            this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\n            this.isRecentlyScrolled = true;\n            this.scrollWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleWheel = () => {\n            this.isRecentlyWheeled = true;\n            this.wheelWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleTouchStart = () => {\n            this.isTouching = true;\n        };\n        this.handleTouchEnd = () => {\n            this.isTouching = false;\n            // if the user ended their touch, and the scroll area wasn't moving,\n            // we consider this to be the end of the scroll.\n            if (!this.isRecentlyScrolled) {\n                this.endScroll(); // won't fire if already ended\n            }\n        };\n        el.addEventListener('scroll', this.handleScroll);\n        el.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.addEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.addEventListener(eventName, this.handleWheel);\n        }\n    }\n    destroy() {\n        let { el } = this;\n        el.removeEventListener('scroll', this.handleScroll);\n        el.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.removeEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.removeEventListener(eventName, this.handleWheel);\n        }\n    }\n    // Start / Stop\n    // ----------------------------------------------------------------------------------------------\n    startScroll() {\n        if (!this.isScrolling) {\n            this.isScrolling = true;\n            this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n        }\n    }\n    endScroll() {\n        if (this.isScrolling) {\n            this.emitter.trigger('scrollEnd');\n            this.isScrolling = false;\n            this.isRecentlyScrolled = true;\n            this.isRecentlyWheeled = false;\n            this.scrollWaiter.clear();\n            this.wheelWaiter.clear();\n        }\n    }\n    _handleScrollWaited() {\n        this.isRecentlyScrolled = false;\n        // only end the scroll if not currently touching.\n        // if touching, the scrolling will end later, on touchend.\n        if (!this.isTouching) {\n            this.endScroll(); // won't fire if already ended\n        }\n    }\n    _handleWheelWaited() {\n        this.isRecentlyWheeled = false;\n    }\n}\n\nclass ScrollSyncer {\n    constructor(isVertical, scrollEls) {\n        this.isVertical = isVertical;\n        this.scrollEls = scrollEls;\n        this.isPaused = false;\n        this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));\n    }\n    destroy() {\n        for (let scrollListener of this.scrollListeners) {\n            scrollListener.destroy();\n        }\n    }\n    bindScroller(el) {\n        let { scrollEls, isVertical } = this;\n        let scrollListener = new ScrollListener(el);\n        const onScroll = (isWheel, isTouch) => {\n            if (!this.isPaused) {\n                if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n                    this.assignMaster(el);\n                }\n                if (this.masterEl === el) { // dealing with current\n                    for (let otherEl of scrollEls) {\n                        if (otherEl !== el) {\n                            if (isVertical) {\n                                otherEl.scrollTop = el.scrollTop;\n                            }\n                            else {\n                                otherEl.scrollLeft = el.scrollLeft;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const onScrollEnd = () => {\n            if (this.masterEl === el) {\n                this.masterEl = null;\n            }\n        };\n        scrollListener.emitter.on('scroll', onScroll);\n        scrollListener.emitter.on('scrollEnd', onScrollEnd);\n        return scrollListener;\n    }\n    assignMaster(el) {\n        this.masterEl = el;\n        for (let scrollListener of this.scrollListeners) {\n            if (scrollListener.el !== el) {\n                scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n            }\n        }\n    }\n    /*\n    will normalize the scrollLeft value\n    */\n    forceScrollLeft(scrollLeft) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            setScrollFromLeftEdge(listener.el, scrollLeft);\n        }\n        this.isPaused = false;\n    }\n    forceScrollTop(top) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            listener.el.scrollTop = top;\n        }\n        this.isPaused = false;\n    }\n}\n\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nclass ScrollGrid extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n        this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n        this.clippedScrollerRefs = new RefMap();\n        // doesn't hold non-scrolling els used just for padding\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\n        this.scrollSyncersBySection = {};\n        this.scrollSyncersByColumn = {};\n        // for row-height-syncing\n        this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n        this.rowInnerMaxHeightMap = new Map();\n        this.anyRowHeightsChanged = false;\n        this.recentSizingCnt = 0;\n        this.state = {\n            shrinkWidths: [],\n            forceYScrollbars: false,\n            forceXScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {},\n            sectionRowMaxHeights: [],\n        };\n        this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\n            if (!this.allowSizing()) {\n                return;\n            }\n            if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n                this.anyRowHeightsChanged = true;\n            }\n            let otherState = {};\n            // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n            if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n                otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\n            }\n            this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {\n                if (!this.rowUnstableMap.size) {\n                    this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n                }\n            });\n        };\n        this.handleRowHeightChange = (rowEl, isStable) => {\n            let { rowUnstableMap, rowInnerMaxHeightMap } = this;\n            if (!isStable) {\n                rowUnstableMap.set(rowEl, true);\n            }\n            else {\n                rowUnstableMap.delete(rowEl);\n                let innerMaxHeight = getRowInnerMaxHeight(rowEl);\n                if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n                    rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n                    this.anyRowHeightsChanged = true;\n                }\n                if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n                    this.anyRowHeightsChanged = false;\n                    this.setState({\n                        sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n                    });\n                }\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { shrinkWidths } = state;\n        let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));\n        let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        this.getDims();\n        // TODO: make DRY\n        let sectionConfigs = props.sections;\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n            headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n            bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n            footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n        const roleAttrs = { role: 'rowgroup' };\n        return createElement('table', {\n            ref: props.elRef,\n            role: 'grid',\n            className: classNames.join(' '),\n        }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n        if ('outerContent' in sectionConfig) {\n            return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n        }\n        return (createElement(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader))));\n    }\n    renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n        if ('outerContent' in chunkConfig) {\n            return (createElement(Fragment, { key: chunkConfig.key }, chunkConfig.outerContent));\n        }\n        let { state } = this;\n        let { scrollerClientWidths, scrollerClientHeights } = state;\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let index = sectionIndex * chunksPerSection + chunkIndex;\n        let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let isVScrollSide = chunkIndex === sideScrollIndex;\n        let isLastSection = sectionIndex === sectionCnt - 1;\n        let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n        let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n        let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n        let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n        let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n        let expandRows = sectionConfig.expandRows && chunkVGrow;\n        let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || '';\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth,\n            clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n            clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n            expandRows,\n            syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n            rowSyncHeights: rowHeights,\n            reportRowHeightChange: this.handleRowHeightChange,\n        }, isHeader);\n        let overflowX = forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n            !allowXScrolling ? 'hidden' :\n                (isLastSection ? 'auto' : 'scroll-hidden');\n        let overflowY = forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n            !allowYScrolling ? 'hidden' :\n                (isVScrollSide ? 'auto' : 'scroll-hidden');\n        // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n        // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n        content = (createElement(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index), scrollerElRef: this.scrollerElRefs.createRef(index), overflowX: overflowX, overflowY: overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content));\n        return createElement(isHeader ? 'th' : 'td', {\n            key: chunkConfig.key,\n            ref: this.chunkElRefs.createRef(index),\n            role: 'presentation',\n        }, content);\n    }\n    componentDidMount() {\n        this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n        this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n        this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n        this.updateScrollSyncers();\n        this.handleSizing(false);\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        this.updateScrollSyncers();\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n        this.destroyScrollSyncers();\n    }\n    allowSizing() {\n        let now = new Date();\n        if (!this.lastSizingDate ||\n            now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n            this.lastSizingDate = now;\n            this.recentSizingCnt = 0;\n            return true;\n        }\n        return (this.recentSizingCnt += 1) <= 10;\n    }\n    computeShrinkWidths() {\n        let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let shrinkWidths = [];\n        colGroupStats.forEach((colGroupStat, i) => {\n            if (colGroupStat.hasShrinkCol) {\n                let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n                shrinkWidths[i] = computeShrinkWidth(chunkEls);\n            }\n        });\n        return shrinkWidths;\n    }\n    // has the side effect of grooming rowInnerMaxHeightMap\n    // TODO: somehow short-circuit if there are no new height changes\n    computeSectionRowMaxHeights() {\n        let newHeightMap = new Map();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sectionRowMaxHeights = [];\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let sectionConfig = this.props.sections[sectionI];\n            let assignableHeights = []; // chunk, row\n            if (sectionConfig && sectionConfig.syncRowHeights) {\n                let rowHeightsByChunk = [];\n                for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                    let index = sectionI * chunksPerSection + chunkI;\n                    let rowHeights = [];\n                    let chunkEl = this.chunkElRefs.currentMap[index];\n                    if (chunkEl) {\n                        rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl) => {\n                            let max = getRowInnerMaxHeight(rowEl);\n                            newHeightMap.set(rowEl, max);\n                            return max;\n                        });\n                    }\n                    else {\n                        rowHeights = [];\n                    }\n                    rowHeightsByChunk.push(rowHeights);\n                }\n                let rowCnt = rowHeightsByChunk[0].length;\n                let isEqualRowCnt = true;\n                for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n                    let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n                    if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n                        isEqualRowCnt = false;\n                        break;\n                    }\n                }\n                if (!isEqualRowCnt) {\n                    let chunkHeightSums = [];\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n                    }\n                    let maxTotalSum = Math.max(...chunkHeightSums);\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n                        let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n                        // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n                        let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n                        // whatever is leftover goes to the first row\n                        let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n                        let rowInChunkHeights = [];\n                        let row = 0;\n                        if (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightFirst);\n                            row += 1;\n                        }\n                        while (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightOthers);\n                            row += 1;\n                        }\n                        assignableHeights.push(rowInChunkHeights);\n                    }\n                }\n                else {\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        assignableHeights.push([]);\n                    }\n                    for (let row = 0; row < rowCnt; row += 1) {\n                        let rowHeightsAcrossChunks = [];\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            let h = rowHeightsByChunk[chunkI][row];\n                            if (h != null) { // protect against outerContent\n                                rowHeightsAcrossChunks.push(h);\n                            }\n                        }\n                        let maxHeight = Math.max(...rowHeightsAcrossChunks);\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            assignableHeights[chunkI].push(maxHeight);\n                        }\n                    }\n                }\n            }\n            sectionRowMaxHeights.push(assignableHeights);\n        }\n        this.rowInnerMaxHeightMap = newHeightMap;\n        return sectionRowMaxHeights;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let lastSectionI = sectionCnt - 1;\n        let currentScrollers = this.clippedScrollerRefs.currentMap;\n        let scrollerEls = this.scrollerElRefs.currentMap;\n        let forceYScrollbars = false;\n        let forceXScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n            let index = sectionI * chunksPerSection + sideScrollI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n            let index = lastSectionI * chunksPerSection + chunkI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsXScrolling()) {\n                forceXScrollbars = true;\n                break;\n            }\n        }\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                let index = sectionI * chunksPerSection + chunkI;\n                let scrollerEl = scrollerEls[index];\n                if (scrollerEl) {\n                    // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    let harnessEl = scrollerEl.parentNode;\n                    scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - ((chunkI === sideScrollI && forceYScrollbars)\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                    scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - ((sectionI === lastSectionI && forceXScrollbars)\n                        ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                }\n            }\n        }\n        return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };\n    }\n    updateStickyScrolling() {\n        let { isRtl } = this.context;\n        let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);\n        this.getStickyScrolling(argsByKey)\n            .forEach((stickyScrolling) => stickyScrolling.updateSize());\n    }\n    updateScrollSyncers() {\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let scrollElsBySection = {};\n        let scrollElsByColumn = {};\n        let scrollElMap = this.scrollerElRefs.currentMap;\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let startIndex = sectionI * chunksPerSection;\n            let endIndex = startIndex + chunksPerSection;\n            scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n        }\n        for (let col = 0; col < chunksPerSection; col += 1) {\n            scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n        }\n        this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n        this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n    }\n    destroyScrollSyncers() {\n        mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n        mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n    }\n    getChunkConfigByIndex(index) {\n        let chunksPerSection = this.getDims()[1];\n        let sectionI = Math.floor(index / chunksPerSection);\n        let chunkI = index % chunksPerSection;\n        let sectionConfig = this.props.sections[sectionI];\n        return sectionConfig && sectionConfig.chunks[chunkI];\n    }\n    forceScrollLeft(col, scrollLeft) {\n        let scrollSyncer = this.scrollSyncersByColumn[col];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollLeft(scrollLeft);\n        }\n    }\n    forceScrollTop(sectionI, scrollTop) {\n        let scrollSyncer = this.scrollSyncersBySection[sectionI];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollTop(scrollTop);\n        }\n    }\n    _handleChunkEl(chunkEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.elRef, chunkEl);\n        }\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\n        }\n    }\n    getDims() {\n        let sectionCnt = this.props.sections.length;\n        let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n        return [sectionCnt, chunksPerSection];\n    }\n}\nScrollGrid.addStateEquality({\n    shrinkWidths: isArraysEqual,\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual,\n});\nfunction sumNumbers(numbers) {\n    let sum = 0;\n    for (let n of numbers) {\n        sum += n;\n    }\n    return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n    let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n    if (innerHeights.length) {\n        return Math.max(...innerHeights);\n    }\n    return 0;\n}\nfunction getElHeight(el) {\n    return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n    let children = colGroupStats.map((colGroupStat, i) => {\n        let width = colGroupStat.width;\n        if (width === 'shrink') {\n            width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n        }\n        return ( // eslint-disable-next-line react/jsx-key\n        createElement(\"col\", { style: { width } }));\n    });\n    return createElement('colgroup', {}, ...children);\n}\nfunction compileColGroupStat(colGroupConfig) {\n    let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n    let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n    let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n    let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n    return {\n        hasShrinkCol,\n        totalColWidth,\n        totalColMinWidth,\n        allowXScrolling,\n        cols: colGroupConfig.cols,\n        width: colGroupConfig.width,\n    };\n}\nfunction sumColProp(cols, propName) {\n    let total = 0;\n    for (let col of cols) {\n        let val = col[propName];\n        if (typeof val === 'number') {\n            total += val * (col.span || 1);\n        }\n    }\n    return total;\n}\nconst COL_GROUP_STAT_EQUALITY = {\n    cols: isColPropsEqual,\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n    return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical, ...scrollEls) {\n    return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n    scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n    return new StickyScrolling(scrollEl, isRtl);\n}\n\nexport { ScrollGrid };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}