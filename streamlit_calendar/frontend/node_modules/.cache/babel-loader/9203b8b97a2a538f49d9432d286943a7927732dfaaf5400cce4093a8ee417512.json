{"ast":null,"code":"import { injectStyles, config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, BaseComponent, memoizeObjArg, memoize, getDateMeta, ContentContainer, getSlotClassNames, getDayClassNames, buildNavLinkAttrs, PositionCache, findDirectChildren, rangeContainsMarker, NowTimer, NowIndicatorContainer, findElements, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, Slicer, intersectRanges, addMs, StandardEvent, MoreLinkContainer, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewContainer, renderScrollShim } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment, createRef } from '@fullcalendar/core/preact.js';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid/internal.js';\nvar css_248z = \".fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:\\\"\\\";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}\";\ninjectStyles(css_248z);\nconst MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\nconst MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\nconst MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000;\n// potential nice values for slot-duration and interval-duration\nconst STOCK_SUB_DURATIONS = [{\n  years: 1\n}, {\n  months: 1\n}, {\n  days: 1\n}, {\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  minutes: 10\n}, {\n  minutes: 5\n}, {\n  minutes: 1\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}, {\n  seconds: 10\n}, {\n  seconds: 5\n}, {\n  seconds: 1\n}, {\n  milliseconds: 500\n}, {\n  milliseconds: 100\n}, {\n  milliseconds: 10\n}, {\n  milliseconds: 1\n}];\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n  let tDateProfile = {\n    labelInterval: allOptions.slotLabelInterval,\n    slotDuration: allOptions.slotDuration\n  };\n  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n  let input = allOptions.slotLabelFormat;\n  let rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n  tDateProfile.headerFormats = rawFormats.map(rawFormat => createFormatter(rawFormat));\n  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n  let largeUnit = null;\n  if (!tDateProfile.isTimeScale) {\n    const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n    if (/year|month|week/.test(slotUnit)) {\n      largeUnit = slotUnit;\n    }\n  }\n  tDateProfile.largeUnit = largeUnit;\n  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs('weeks', dateProfile, dateEnv) >= 2 && !allOptions.businessHours;\n  /*\n  console.log('label interval =', timelineView.labelInterval.humanize())\n  console.log('slot duration =', timelineView.slotDuration.humanize())\n  console.log('header formats =', timelineView.headerFormats)\n  console.log('isTimeScale', timelineView.isTimeScale)\n  console.log('largeUnit', timelineView.largeUnit)\n  */\n  let rawSnapDuration = allOptions.snapDuration;\n  let snapDuration;\n  let snapsPerSlot;\n  if (rawSnapDuration) {\n    snapDuration = createDuration(rawSnapDuration);\n    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);\n    // ^ TODO: warning if not whole?\n  }\n\n  if (snapsPerSlot == null) {\n    snapDuration = tDateProfile.slotDuration;\n    snapsPerSlot = 1;\n  }\n  tDateProfile.snapDuration = snapDuration;\n  tDateProfile.snapsPerSlot = snapsPerSlot;\n  // more...\n  let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);\n  // TODO: why not use normalizeRange!?\n  let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n  let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);\n  // apply slotMinTime/slotMaxTime\n  // TODO: View should be responsible.\n  if (tDateProfile.isTimeScale) {\n    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n  }\n  tDateProfile.timeWindowMs = timeWindowMs;\n  tDateProfile.normalizedRange = {\n    start: normalizedStart,\n    end: normalizedEnd\n  };\n  let slotDates = [];\n  let date = normalizedStart;\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      slotDates.push(date);\n    }\n    date = dateEnv.add(date, tDateProfile.slotDuration);\n  }\n  tDateProfile.slotDates = slotDates;\n  // more...\n  let snapIndex = -1;\n  let snapDiff = 0; // index of the diff :(\n  const snapDiffToIndex = [];\n  const snapIndexToDiff = [];\n  date = normalizedStart;\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      snapIndex += 1;\n      snapDiffToIndex.push(snapIndex);\n      snapIndexToDiff.push(snapDiff);\n    } else {\n      snapDiffToIndex.push(snapIndex + 0.5);\n    }\n    date = dateEnv.add(date, tDateProfile.snapDuration);\n    snapDiff += 1;\n  }\n  tDateProfile.snapDiffToIndex = snapDiffToIndex;\n  tDateProfile.snapIndexToDiff = snapIndexToDiff;\n  tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;\n  // more...\n  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n  return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n  let normalDate = date;\n  if (!tDateProfile.isTimeScale) {\n    normalDate = startOfDay(normalDate);\n    if (tDateProfile.largeUnit) {\n      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n    }\n  }\n  return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n  if (!tDateProfile.isTimeScale) {\n    range = computeVisibleDayRange(range);\n    if (tDateProfile.largeUnit) {\n      let dayRange = range; // preserve original result\n      range = {\n        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)\n      };\n      // if date is partially through the interval, or is in the same interval as the start,\n      // make the exclusive end be the *next* interval\n      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n        range = {\n          start: range.start,\n          end: dateEnv.add(range.end, tDateProfile.slotDuration)\n        };\n      }\n    }\n  }\n  return range;\n}\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n  if (dateProfileGenerator.isHiddenDay(date)) {\n    return false;\n  }\n  if (tDateProfile.isTimeScale) {\n    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n    let day = startOfDay(date);\n    let timeMs = date.valueOf() - day.valueOf();\n    let ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n    ms = (ms % 86400000 + 86400000) % 86400000; // make negative values wrap to 24hr clock\n    return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n  }\n\n  return true;\n}\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n  const {\n    currentRange\n  } = dateProfile;\n  // make sure labelInterval doesn't exceed the max number of cells\n  if (tDateProfile.labelInterval) {\n    const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n    if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotLabelInterval results in too many cells');\n      tDateProfile.labelInterval = null;\n    }\n  }\n  // make sure slotDuration doesn't exceed the maximum number of cells\n  if (tDateProfile.slotDuration) {\n    const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n    if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotDuration results in too many cells');\n      tDateProfile.slotDuration = null;\n    }\n  }\n  // make sure labelInterval is a multiple of slotDuration\n  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n    const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n    if (slotsPerLabel === null || slotsPerLabel < 1) {\n      console.warn('slotLabelInterval must be a multiple of slotDuration');\n      tDateProfile.slotDuration = null;\n    }\n  }\n}\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n  const {\n    currentRange\n  } = dateProfile;\n  let {\n    labelInterval\n  } = tDateProfile;\n  if (!labelInterval) {\n    // compute based off the slot duration\n    // find the largest label interval with an acceptable slots-per-label\n    let input;\n    if (tDateProfile.slotDuration) {\n      for (input of STOCK_SUB_DURATIONS) {\n        const tryLabelInterval = createDuration(input);\n        const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          labelInterval = tryLabelInterval;\n          break;\n        }\n      }\n      // use the slot duration as a last resort\n      if (!labelInterval) {\n        labelInterval = tDateProfile.slotDuration;\n      }\n      // compute based off the view's duration\n      // find the largest label interval that yields the minimum number of labels\n    } else {\n      for (input of STOCK_SUB_DURATIONS) {\n        labelInterval = createDuration(input);\n        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n        if (labelCnt >= MIN_AUTO_LABELS) {\n          break;\n        }\n      }\n    }\n    tDateProfile.labelInterval = labelInterval;\n  }\n  return labelInterval;\n}\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n  const {\n    currentRange\n  } = dateProfile;\n  let {\n    slotDuration\n  } = tDateProfile;\n  if (!slotDuration) {\n    const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n    // compute based off the label interval\n    // find the largest slot duration that is different from labelInterval, but still acceptable\n    for (let input of STOCK_SUB_DURATIONS) {\n      const trySlotDuration = createDuration(input);\n      const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n        slotDuration = trySlotDuration;\n        break;\n      }\n    }\n    // only allow the value if it won't exceed the view's # of slots limit\n    if (slotDuration) {\n      const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n      if (slotCnt > MAX_AUTO_CELLS) {\n        slotDuration = null;\n      }\n    }\n    // use the label interval as a last resort\n    if (!slotDuration) {\n      slotDuration = labelInterval;\n    }\n    tDateProfile.slotDuration = slotDuration;\n  }\n  return slotDuration;\n}\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n  let format1;\n  let format2;\n  const {\n    labelInterval\n  } = tDateProfile;\n  let unit = greatestDurationDenominator(labelInterval).unit;\n  const weekNumbersVisible = allOptions.weekNumbers;\n  let format0 = format1 = format2 = null;\n  // NOTE: weekNumber computation function wont work\n  if (unit === 'week' && !weekNumbersVisible) {\n    unit = 'day';\n  }\n  switch (unit) {\n    case 'year':\n      format0 = {\n        year: 'numeric'\n      }; // '2015'\n      break;\n    case 'month':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        month: 'short'\n      }; // 'Jan'\n      break;\n    case 'week':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        week: 'narrow'\n      }; // 'Wk4'\n      break;\n    case 'day':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric',\n          month: 'long'\n        }; // 'January 2014'\n      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n        format0 = {\n          month: 'long'\n        }; // 'January'\n      }\n\n      if (weekNumbersVisible) {\n        format1 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      format2 = {\n        weekday: 'narrow',\n        day: 'numeric'\n      }; // 'Su 9'\n      break;\n    case 'hour':\n      if (weekNumbersVisible) {\n        format0 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n        format1 = {\n          weekday: 'short',\n          day: 'numeric',\n          month: 'numeric',\n          omitCommas: true\n        }; // Sat 4/7\n      }\n\n      format2 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short'\n      };\n      break;\n    case 'minute':\n      // sufficiently large number of different minute cells?\n      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          meridiem: 'short'\n        };\n        format1 = params => ':' + padStart(params.date.minute, 2) // ':30'\n        ;\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: 'numeric',\n          meridiem: 'short'\n        };\n      }\n      break;\n    case 'second':\n      // sufficiently large number of different second cells?\n      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30 PM'\n        format1 = params => ':' + padStart(params.date.second, 2) // ':30'\n        ;\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          second: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30:45 PM'\n      }\n\n      break;\n    case 'millisecond':\n      format0 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        second: '2-digit',\n        meridiem: 'lowercase'\n      }; // '8:30:45 PM'\n      format1 = params => '.' + padStart(params.millisecond, 3);\n      break;\n  }\n  return [].concat(format0 || [], format1 || [], format2 || []);\n}\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n  let range = dateProfile.currentRange;\n  let res = null;\n  if (unit === 'years') {\n    res = dateEnv.diffWholeYears(range.start, range.end);\n  } else if (unit === 'months') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'weeks') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'days') {\n    res = diffWholeDays(range.start, range.end);\n  }\n  return res || 0;\n}\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n  let {\n    slotDates,\n    emphasizeWeeks\n  } = tDateProfile;\n  let prevWeekNumber = null;\n  let isWeekStarts = [];\n  for (let slotDate of slotDates) {\n    let weekNumber = dateEnv.computeWeekNumber(slotDate);\n    let isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;\n    prevWeekNumber = weekNumber;\n    isWeekStarts.push(isWeekStart);\n  }\n  return isWeekStarts;\n}\nfunction buildCellRows(tDateProfile, dateEnv) {\n  let slotDates = tDateProfile.slotDates;\n  let formats = tDateProfile.headerFormats;\n  let cellRows = formats.map(() => []); // indexed by row,col\n  let slotAsDays = asCleanDays(tDateProfile.slotDuration);\n  let guessedSlotUnit = slotAsDays === 7 ? 'week' : slotAsDays === 1 ? 'day' : null;\n  // specifically for navclicks\n  let rowUnitsFromFormats = formats.map(format => format.getLargestUnit ? format.getLargestUnit() : null);\n  // builds cellRows and slotCells\n  for (let i = 0; i < slotDates.length; i += 1) {\n    let date = slotDates[i];\n    let isWeekStart = tDateProfile.isWeekStarts[i];\n    for (let row = 0; row < formats.length; row += 1) {\n      let format = formats[row];\n      let rowCells = cellRows[row];\n      let leadingCell = rowCells[rowCells.length - 1];\n      let isLastRow = row === formats.length - 1;\n      let isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n      let newCell = null;\n      let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n      if (isSuperRow) {\n        let text = dateEnv.format(date, format);\n        if (!leadingCell || leadingCell.text !== text) {\n          newCell = buildCellObject(date, text, rowUnit);\n        } else {\n          leadingCell.colspan += 1;\n        }\n      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n        let text = dateEnv.format(date, format);\n        newCell = buildCellObject(date, text, rowUnit);\n      } else {\n        leadingCell.colspan += 1;\n      }\n      if (newCell) {\n        newCell.weekStart = isWeekStart;\n        rowCells.push(newCell);\n      }\n    }\n  }\n  return cellRows;\n}\nfunction buildCellObject(date, text, rowUnit) {\n  return {\n    date,\n    text,\n    rowUnit,\n    colspan: 1,\n    isWeekStart: false\n  };\n}\nclass TimelineHeaderTh extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.refineRenderProps = memoizeObjArg(refineRenderProps);\n    this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n  }\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      dateEnv,\n      options\n    } = context;\n    let {\n      cell,\n      dateProfile,\n      tDateProfile\n    } = props;\n    // the cell.rowUnit is f'd\n    // giving 'month' for a 3-day view\n    // workaround: to infer day, do NOT time\n    let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n    let renderProps = this.refineRenderProps({\n      level: props.rowLevel,\n      dateMarker: cell.date,\n      text: cell.text,\n      dateEnv: context.dateEnv,\n      viewApi: context.viewApi\n    });\n    return createElement(ContentContainer, {\n      elTag: \"th\",\n      elClasses: ['fc-timeline-slot', 'fc-timeline-slot-label', cell.isWeekStart && 'fc-timeline-slot-em', ...(\n      // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n      cell.rowUnit === 'time' ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme))],\n      elAttrs: {\n        colSpan: cell.colspan,\n        'data-date': dateEnv.formatIso(cell.date, {\n          omitTime: !tDateProfile.isTimeScale,\n          omitTimeZoneOffset: true\n        })\n      },\n      renderProps: renderProps,\n      generatorName: \"slotLabelContent\",\n      customGenerator: options.slotLabelContent,\n      defaultGenerator: renderInnerContent,\n      classNameGenerator: options.slotLabelClassNames,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, InnerContent => createElement(\"div\", {\n      className: \"fc-timeline-slot-frame\",\n      style: {\n        height: props.rowInnerHeight\n      }\n    }, createElement(InnerContent, {\n      elTag: \"a\",\n      elClasses: ['fc-timeline-slot-cushion', 'fc-scrollgrid-sync-inner', props.isSticky && 'fc-sticky'],\n      elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)\n    })));\n  }\n}\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n  return rowUnit && rowUnit !== 'time' ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};\n}\nfunction renderInnerContent(renderProps) {\n  return renderProps.text;\n}\nfunction refineRenderProps(input) {\n  return {\n    level: input.level,\n    date: input.dateEnv.toDate(input.dateMarker),\n    view: input.viewApi,\n    text: input.text\n  };\n}\nclass TimelineHeaderRows extends BaseComponent {\n  render() {\n    let {\n      dateProfile,\n      tDateProfile,\n      rowInnerHeights,\n      todayRange,\n      nowDate\n    } = this.props;\n    let {\n      cellRows\n    } = tDateProfile;\n    return createElement(Fragment, null, cellRows.map((rowCells, rowLevel) => {\n      let isLast = rowLevel === cellRows.length - 1;\n      let isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n      let classNames = ['fc-timeline-header-row', isChrono ? 'fc-timeline-header-row-chrono' : ''];\n      return (\n        // eslint-disable-next-line react/no-array-index-key\n        createElement(\"tr\", {\n          key: rowLevel,\n          className: classNames.join(' ')\n        }, rowCells.map(cell => createElement(TimelineHeaderTh, {\n          key: cell.date.toISOString(),\n          cell: cell,\n          rowLevel: rowLevel,\n          dateProfile: dateProfile,\n          tDateProfile: tDateProfile,\n          todayRange: todayRange,\n          nowDate: nowDate,\n          rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel],\n          isSticky: !isLast\n        })))\n      );\n    }));\n  }\n}\nclass TimelineCoords {\n  constructor(slatRootEl,\n  // okay to expose?\n  slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n    this.slatRootEl = slatRootEl;\n    this.dateProfile = dateProfile;\n    this.tDateProfile = tDateProfile;\n    this.dateEnv = dateEnv;\n    this.isRtl = isRtl;\n    this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true,\n    // isHorizontal\n    false);\n    // for the inner divs within the slats\n    // used for event rendering and scrollTime, to disregard slat border\n    this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true,\n    // isHorizontal\n    false);\n  }\n  isDateInRange(date) {\n    return rangeContainsMarker(this.dateProfile.currentRange, date);\n  }\n  // results range from negative width of area to 0\n  dateToCoord(date) {\n    let {\n      tDateProfile\n    } = this;\n    let snapCoverage = this.computeDateSnapCoverage(date);\n    let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n    let slotIndex = Math.floor(slotCoverage);\n    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n    let partial = slotCoverage - slotIndex;\n    let {\n      innerCoordCache,\n      outerCoordCache\n    } = this;\n    if (this.isRtl) {\n      return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);\n    }\n    return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;\n  }\n  rangeToCoords(range) {\n    return {\n      start: this.dateToCoord(range.start),\n      end: this.dateToCoord(range.end)\n    };\n  }\n  durationToCoord(duration) {\n    let {\n      dateProfile,\n      tDateProfile,\n      dateEnv,\n      isRtl\n    } = this;\n    let coord = 0;\n    if (dateProfile) {\n      let date = dateEnv.add(dateProfile.activeRange.start, duration);\n      if (!tDateProfile.isTimeScale) {\n        date = startOfDay(date);\n      }\n      coord = this.dateToCoord(date);\n      // hack to overcome the left borders of non-first slat\n      if (!isRtl && coord) {\n        coord += 1;\n      }\n    }\n    return coord;\n  }\n  coordFromLeft(coord) {\n    if (this.isRtl) {\n      return this.outerCoordCache.originClientRect.width - coord;\n    }\n    return coord;\n  }\n  // returned value is between 0 and the number of snaps\n  computeDateSnapCoverage(date) {\n    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n  }\n}\n// returned value is between 0 and the number of snaps\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n  let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n  if (snapDiff < 0) {\n    return 0;\n  }\n  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n    return tDateProfile.snapCnt;\n  }\n  let snapDiffInt = Math.floor(snapDiff);\n  let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n  if (isInt(snapCoverage)) {\n    // not an in-between value\n    snapCoverage += snapDiff - snapDiffInt; // add the remainder\n  } else {\n    // a fractional value, meaning the date is not visible\n    // always round up in this case. works for start AND end dates in a range.\n    snapCoverage = Math.ceil(snapCoverage);\n  }\n  return snapCoverage;\n}\nfunction coordToCss(hcoord, isRtl) {\n  if (hcoord === null) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n  if (isRtl) {\n    return {\n      right: hcoord,\n      left: ''\n    };\n  }\n  return {\n    left: hcoord,\n    right: ''\n  };\n}\nfunction coordsToCss(hcoords, isRtl) {\n  if (!hcoords) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n  if (isRtl) {\n    return {\n      right: hcoords.start,\n      left: -hcoords.end\n    };\n  }\n  return {\n    left: hcoords.start,\n    right: -hcoords.end\n  };\n}\nclass TimelineHeader extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.rootElRef = createRef();\n  }\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    // TODO: very repetitive\n    // TODO: make part of tDateProfile?\n    let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;\n    // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n    let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n    return createElement(NowTimer, {\n      unit: timerUnit\n    }, (nowDate, todayRange) => createElement(\"div\", {\n      className: \"fc-timeline-header\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: \"fc-scrollgrid-sync-table\",\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(\"tbody\", null, createElement(TimelineHeaderRows, {\n      dateProfile: props.dateProfile,\n      tDateProfile: props.tDateProfile,\n      nowDate: nowDate,\n      todayRange: todayRange,\n      rowInnerHeights: props.rowInnerHeights\n    }))), context.options.nowIndicator &&\n    // need to have a container regardless of whether the current view has a visible now indicator\n    // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n    // this issue doesn't happen for the timeline body however (\n    createElement(\"div\", {\n      className: \"fc-timeline-now-indicator-container\"\n    }, slatCoords && slatCoords.isDateInRange(nowDate) && createElement(NowIndicatorContainer, {\n      elClasses: ['fc-timeline-now-indicator-arrow'],\n      elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl),\n      isAxis: true,\n      date: nowDate\n    }))));\n  }\n  componentDidMount() {\n    this.updateSize();\n  }\n  componentDidUpdate() {\n    this.updateSize();\n  }\n  updateSize() {\n    if (this.props.onMaxCushionWidth) {\n      this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n    }\n  }\n  computeMaxCushionWidth() {\n    return Math.max(...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(el => el.getBoundingClientRect().width));\n  }\n}\nclass TimelineSlatCell extends BaseComponent {\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      dateEnv,\n      options,\n      theme\n    } = context;\n    let {\n      date,\n      tDateProfile,\n      isEm\n    } = props;\n    let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n    let renderProps = Object.assign(Object.assign({\n      date: dateEnv.toDate(props.date)\n    }, dateMeta), {\n      view: context.viewApi\n    });\n    return createElement(ContentContainer, {\n      elTag: \"td\",\n      elRef: props.elRef,\n      elClasses: ['fc-timeline-slot', 'fc-timeline-slot-lane', isEm && 'fc-timeline-slot-em', tDateProfile.isTimeScale ? isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? 'fc-timeline-slot-major' : 'fc-timeline-slot-minor' : '', ...(props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme))],\n      elAttrs: {\n        'data-date': dateEnv.formatIso(date, {\n          omitTimeZoneOffset: true,\n          omitTime: !tDateProfile.isTimeScale\n        })\n      },\n      renderProps: renderProps,\n      generatorName: \"slotLaneContent\",\n      customGenerator: options.slotLaneContent,\n      classNameGenerator: options.slotLaneClassNames,\n      didMount: options.slotLaneDidMount,\n      willUnmount: options.slotLaneWillUnmount\n    }, InnerContent => createElement(InnerContent, {\n      elTag: \"div\"\n    }));\n  }\n}\nclass TimelineSlatsBody extends BaseComponent {\n  render() {\n    let {\n      props\n    } = this;\n    let {\n      tDateProfile,\n      cellElRefs\n    } = props;\n    let {\n      slotDates,\n      isWeekStarts\n    } = tDateProfile;\n    let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n    return createElement(\"tbody\", null, createElement(\"tr\", null, slotDates.map((slotDate, i) => {\n      let key = slotDate.toISOString();\n      return createElement(TimelineSlatCell, {\n        key: key,\n        elRef: cellElRefs.createRef(key),\n        date: slotDate,\n        dateProfile: props.dateProfile,\n        tDateProfile: tDateProfile,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        isEm: isWeekStarts[i],\n        isDay: isDay\n      });\n    })));\n  }\n}\nclass TimelineSlats extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.rootElRef = createRef();\n    this.cellElRefs = new RefMap();\n    this.handleScrollRequest = request => {\n      let {\n        onScrollLeftRequest\n      } = this.props;\n      let {\n        coords\n      } = this;\n      if (onScrollLeftRequest && coords) {\n        if (request.time) {\n          let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n          onScrollLeftRequest(scrollLeft);\n        }\n        return true;\n      }\n      return null; // best?\n    };\n  }\n\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    return createElement(\"div\", {\n      className: \"fc-timeline-slots\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(TimelineSlatsBody, {\n      cellElRefs: this.cellElRefs,\n      dateProfile: props.dateProfile,\n      tDateProfile: props.tDateProfile,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange\n    })));\n  }\n  componentDidMount() {\n    this.updateSizing();\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  }\n  componentDidUpdate(prevProps) {\n    this.updateSizing();\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  }\n  componentWillUnmount() {\n    this.scrollResponder.detach();\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  }\n  updateSizing() {\n    let {\n      props,\n      context\n    } = this;\n    if (props.clientWidth !== null &&\n    // is sizing stable?\n    this.scrollResponder\n    // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n    ) {\n      let rootEl = this.rootElRef.current;\n      if (rootEl.offsetWidth) {\n        // not hidden by css\n        this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n        if (props.onCoords) {\n          props.onCoords(this.coords);\n        }\n        this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n      }\n    }\n  }\n\n  positionToHit(leftPosition) {\n    let {\n      outerCoordCache\n    } = this.coords;\n    let {\n      dateEnv,\n      isRtl\n    } = this.context;\n    let {\n      tDateProfile\n    } = this.props;\n    let slatIndex = outerCoordCache.leftToIndex(leftPosition);\n    if (slatIndex != null) {\n      // somewhat similar to what TimeGrid does. consolidate?\n      let slatWidth = outerCoordCache.getWidth(slatIndex);\n      let partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n      let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n      let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n      let end = dateEnv.add(start, tDateProfile.snapDuration);\n      return {\n        dateSpan: {\n          range: {\n            start,\n            end\n          },\n          allDay: !this.props.tDateProfile.isTimeScale\n        },\n        dayEl: this.cellElRefs.currentMap[slatIndex],\n        left: outerCoordCache.lefts[slatIndex],\n        right: outerCoordCache.rights[slatIndex]\n      };\n    }\n    return null;\n  }\n}\nfunction collectCellEls(elMap, slotDates) {\n  return slotDates.map(slotDate => {\n    let key = slotDate.toISOString();\n    return elMap[key];\n  });\n}\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n  let hcoords = [];\n  if (timelineCoords) {\n    for (let seg of segs) {\n      let res = timelineCoords.rangeToCoords(seg);\n      let start = Math.round(res.start); // for barely-overlapping collisions\n      let end = Math.round(res.end); //\n      if (end - start < minWidth) {\n        end = start + minWidth;\n      }\n      hcoords.push({\n        start,\n        end\n      });\n    }\n  }\n  return hcoords;\n}\nfunction computeFgSegPlacements(segs, segHCoords,\n// might not have for every seg\neventInstanceHeights,\n// might not have for every seg\nmoreLinkHeights,\n// might not have for every more-link\nstrictOrder, maxStackCnt) {\n  let segInputs = [];\n  let crudePlacements = []; // when we don't know dims\n  for (let i = 0; i < segs.length; i += 1) {\n    let seg = segs[i];\n    let instanceId = seg.eventRange.instance.instanceId;\n    let height = eventInstanceHeights[instanceId];\n    let hcoords = segHCoords[i];\n    if (height && hcoords) {\n      segInputs.push({\n        index: i,\n        span: hcoords,\n        thickness: height\n      });\n    } else {\n      crudePlacements.push({\n        seg,\n        hcoords,\n        top: null\n      });\n    }\n  }\n  let hierarchy = new SegHierarchy();\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n  let hiddenEntries = hierarchy.addSegs(segInputs);\n  let hiddenPlacements = hiddenEntries.map(entry => ({\n    seg: segs[entry.index],\n    hcoords: entry.span,\n    top: null\n  }));\n  let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  let moreLinkInputs = [];\n  let moreLinkCrudePlacements = [];\n  const extractSeg = entry => segs[entry.index];\n  for (let i = 0; i < hiddenGroups.length; i += 1) {\n    let hiddenGroup = hiddenGroups[i];\n    let sortedSegs = hiddenGroup.entries.map(extractSeg);\n    let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n    if (height != null) {\n      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n      moreLinkInputs.push({\n        index: segs.length + i,\n        thickness: height,\n        span: hiddenGroup.span\n      });\n    } else {\n      moreLinkCrudePlacements.push({\n        seg: sortedSegs,\n        hcoords: hiddenGroup.span,\n        top: null\n      });\n    }\n  }\n  // add more-links into the hierarchy, but don't limit\n  hierarchy.maxStackCnt = -1;\n  hierarchy.addSegs(moreLinkInputs);\n  let visibleRects = hierarchy.toRects();\n  let visiblePlacements = [];\n  let maxHeight = 0;\n  for (let rect of visibleRects) {\n    let segIndex = rect.index;\n    visiblePlacements.push({\n      seg: segIndex < segs.length ? segs[segIndex] // a real seg\n      : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n      hcoords: rect.span,\n      top: rect.levelCoord\n    });\n    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n  }\n  return [visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements), maxHeight];\n}\nclass TimelineLaneBg extends BaseComponent {\n  render() {\n    let {\n      props\n    } = this;\n    let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n    return props.timelineCoords && createElement(\"div\", {\n      className: \"fc-timeline-bg\"\n    }, this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'), this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'), this.renderSegs(highlightSeg, props.timelineCoords, 'highlight'));\n  }\n  renderSegs(segs, timelineCoords, fillType) {\n    let {\n      todayRange,\n      nowDate\n    } = this.props;\n    let {\n      isRtl\n    } = this.context;\n    let segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n    let children = segs.map((seg, i) => {\n      let hcoords = segHCoords[i];\n      let hStyle = coordsToCss(hcoords, isRtl);\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: \"fc-timeline-bg-harness\",\n        style: hStyle\n      }, fillType === 'bg-event' ? createElement(BgEvent, Object.assign({\n        seg: seg\n      }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  }\n}\nclass TimelineLaneSlicer extends Slicer {\n  sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n    let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n    let segs = [];\n    // protect against when the span is entirely in an invalid date region\n    if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n      // intersect the footprint's range with the grid's range\n      let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n      if (slicedRange) {\n        segs.push({\n          start: slicedRange.start,\n          end: slicedRange.end,\n          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)\n        });\n      }\n    }\n    return segs;\n  }\n}\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\nclass TimelineEvent extends BaseComponent {\n  render() {\n    let {\n      props\n    } = this;\n    return createElement(StandardEvent, Object.assign({}, props, {\n      elClasses: ['fc-timeline-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      defaultDisplayEventTime: !props.isTimeScale\n    }));\n  }\n}\nclass TimelineLaneMoreLink extends BaseComponent {\n  render() {\n    let {\n      props,\n      context\n    } = this;\n    let {\n      hiddenSegs,\n      placement,\n      resourceId\n    } = props;\n    let {\n      top,\n      hcoords\n    } = placement;\n    let isVisible = hcoords && top !== null;\n    let hStyle = coordsToCss(hcoords, context.isRtl);\n    let extraDateSpan = resourceId ? {\n      resourceId\n    } : {};\n    return createElement(MoreLinkContainer, {\n      elRef: props.elRef,\n      elClasses: ['fc-timeline-more-link'],\n      elStyle: Object.assign({\n        visibility: isVisible ? '' : 'hidden',\n        top: top || 0\n      }, hStyle),\n      allDayDate: null,\n      moreCnt: hiddenSegs.length,\n      allSegs: hiddenSegs,\n      hiddenSegs: hiddenSegs,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraDateSpan: extraDateSpan,\n      popoverContent: () => createElement(Fragment, null, hiddenSegs.map(seg => {\n        let instanceId = seg.eventRange.instance.instanceId;\n        return createElement(\"div\", {\n          key: instanceId,\n          style: {\n            visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ''\n          }\n        }, createElement(TimelineEvent, Object.assign({\n          isTimeScale: props.isTimeScale,\n          seg: seg,\n          isDragging: false,\n          isResizing: false,\n          isDateSelecting: false,\n          isSelected: instanceId === props.eventSelection\n        }, getSegMeta(seg, props.todayRange, props.nowDate))));\n      }))\n    }, InnerContent => createElement(InnerContent, {\n      elTag: \"div\",\n      elClasses: ['fc-timeline-more-link-inner', 'fc-sticky']\n    }));\n  }\n}\nclass TimelineLane extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.slicer = new TimelineLaneSlicer();\n    this.sortEventSegs = memoize(sortEventSegs);\n    this.harnessElRefs = new RefMap();\n    this.moreElRefs = new RefMap();\n    this.innerElRef = createRef();\n    // TODO: memoize event positioning\n    this.state = {\n      eventInstanceHeights: {},\n      moreLinkHeights: {}\n    };\n    this.handleResize = isForced => {\n      if (isForced) {\n        this.updateSize();\n      }\n    };\n  }\n  render() {\n    let {\n      props,\n      state,\n      context\n    } = this;\n    let {\n      options\n    } = context;\n    let {\n      dateProfile,\n      tDateProfile\n    } = props;\n    let slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context,\n    // wish we didn't have to pass in the rest of the args...\n    dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n    let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];\n    let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n    let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n    let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);\n    let isForcedInvisible =\n    // TODO: more convenient\n    (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {};\n    return createElement(Fragment, null, createElement(TimelineLaneBg, {\n      businessHourSegs: slicedProps.businessHourSegs,\n      bgEventSegs: slicedProps.bgEventSegs,\n      timelineCoords: props.timelineCoords,\n      eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [] /* bad new empty array? */,\n      dateSelectionSegs: slicedProps.dateSelectionSegs,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange\n    }), createElement(\"div\", {\n      className: \"fc-timeline-events fc-scrollgrid-sync-inner\",\n      ref: this.innerElRef,\n      style: {\n        height: fgHeight\n      }\n    }, this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false), this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)));\n  }\n  componentDidMount() {\n    this.updateSize();\n    this.context.addResizeHandler(this.handleResize);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.eventStore !== this.props.eventStore ||\n    // external thing changed?\n    prevProps.timelineCoords !== this.props.timelineCoords ||\n    // external thing changed?\n    prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n    ) {\n      this.updateSize();\n    }\n  }\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleResize);\n  }\n  updateSize() {\n    let {\n      props\n    } = this;\n    let {\n      timelineCoords\n    } = props;\n    const innerEl = this.innerElRef.current;\n    if (props.onHeightChange) {\n      props.onHeightChange(innerEl, false);\n    }\n    if (timelineCoords) {\n      this.setState({\n        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, harnessEl => Math.round(harnessEl.getBoundingClientRect().height)),\n        moreLinkHeights: mapHash(this.moreElRefs.currentMap, moreEl => Math.round(moreEl.getBoundingClientRect().height))\n      }, () => {\n        if (props.onHeightChange) {\n          props.onHeightChange(innerEl, true);\n        }\n      });\n    }\n    // hack\n    if (props.syncParentMinHeight) {\n      innerEl.parentElement.style.minHeight = innerEl.style.height;\n    }\n  }\n  renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    let {\n      harnessElRefs,\n      moreElRefs,\n      props,\n      context\n    } = this;\n    let isMirror = isDragging || isResizing || isDateSelecting;\n    return createElement(Fragment, null, segPlacements.map(segPlacement => {\n      let {\n        seg,\n        hcoords,\n        top\n      } = segPlacement;\n      if (Array.isArray(seg)) {\n        // a more-link\n        let isoStr = buildIsoString(computeEarliestSegStart(seg));\n        return createElement(TimelineLaneMoreLink, {\n          key: 'm:' + isoStr /* \"m\" for \"more\" */,\n          elRef: moreElRefs.createRef(isoStr),\n          hiddenSegs: seg,\n          placement: segPlacement,\n          dateProfile: props.dateProfile,\n          nowDate: props.nowDate,\n          todayRange: props.todayRange,\n          isTimeScale: props.tDateProfile.isTimeScale,\n          eventSelection: props.eventSelection,\n          resourceId: props.resourceId,\n          isForcedInvisible: isForcedInvisible\n        });\n      }\n      let instanceId = seg.eventRange.instance.instanceId;\n      let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n      let hStyle = coordsToCss(hcoords, context.isRtl);\n      return createElement(\"div\", {\n        key: 'e:' + instanceId /* \"e\" for \"event\" */,\n        ref: isMirror ? null : harnessElRefs.createRef(instanceId),\n        className: \"fc-timeline-event-harness\",\n        style: Object.assign({\n          visibility: isVisible ? '' : 'hidden',\n          top: top || 0\n        }, hStyle)\n      }, createElement(TimelineEvent, Object.assign({\n        isTimeScale: props.tDateProfile.isTimeScale,\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === props.eventSelection /* TODO: bad for mirror? */\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    }));\n  }\n}\nTimelineLane.addStateEquality({\n  eventInstanceHeights: isPropsEqual,\n  moreLinkHeights: isPropsEqual\n});\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n  if (!mirrorSegs.length || !timelineCoords) {\n    return [];\n  }\n  let topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n  return mirrorSegs.map(seg => ({\n    seg,\n    hcoords: timelineCoords.rangeToCoords(seg),\n    top: topsByInstanceId[seg.eventRange.instance.instanceId]\n  }));\n}\nfunction buildAbsoluteTopHash(placements) {\n  let topsByInstanceId = {};\n  for (let placement of placements) {\n    let {\n      seg\n    } = placement;\n    if (!Array.isArray(seg)) {\n      // doesn't represent a more-link\n      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n    }\n  }\n  return topsByInstanceId;\n}\nclass TimelineGrid extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.slatsRef = createRef();\n    this.state = {\n      coords: null\n    };\n    this.handeEl = el => {\n      if (el) {\n        this.context.registerInteractiveComponent(this, {\n          el\n        });\n      } else {\n        this.context.unregisterInteractiveComponent(this);\n      }\n    };\n    this.handleCoords = coords => {\n      this.setState({\n        coords\n      });\n      if (this.props.onSlatCoords) {\n        this.props.onSlatCoords(coords);\n      }\n    };\n  }\n  render() {\n    let {\n      props,\n      state,\n      context\n    } = this;\n    let {\n      options\n    } = context;\n    let {\n      dateProfile,\n      tDateProfile\n    } = props;\n    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n    return createElement(\"div\", {\n      className: \"fc-timeline-body\",\n      ref: this.handeEl,\n      style: {\n        minWidth: props.tableMinWidth,\n        height: props.clientHeight,\n        width: props.clientWidth\n      }\n    }, createElement(NowTimer, {\n      unit: timerUnit\n    }, (nowDate, todayRange) => createElement(Fragment, null, createElement(TimelineSlats, {\n      ref: this.slatsRef,\n      dateProfile: dateProfile,\n      tDateProfile: tDateProfile,\n      nowDate: nowDate,\n      todayRange: todayRange,\n      clientWidth: props.clientWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      onCoords: this.handleCoords,\n      onScrollLeftRequest: props.onScrollLeftRequest\n    }), createElement(TimelineLane, {\n      dateProfile: dateProfile,\n      tDateProfile: props.tDateProfile,\n      nowDate: nowDate,\n      todayRange: todayRange,\n      nextDayThreshold: options.nextDayThreshold,\n      businessHours: props.businessHours,\n      eventStore: props.eventStore,\n      eventUiBases: props.eventUiBases,\n      dateSelection: props.dateSelection,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      timelineCoords: state.coords,\n      syncParentMinHeight: true\n    }), options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && createElement(\"div\", {\n      className: \"fc-timeline-now-indicator-container\"\n    }, createElement(NowIndicatorContainer, {\n      elClasses: ['fc-timeline-now-indicator-line'],\n      elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl),\n      isAxis: false,\n      date: nowDate\n    })))));\n  }\n  // Hit System\n  // ------------------------------------------------------------------------------------------\n  queryHit(positionLeft, positionTop, elWidth, elHeight) {\n    let slats = this.slatsRef.current;\n    let slatHit = slats.positionToHit(positionLeft);\n    if (slatHit) {\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: slatHit.dateSpan,\n        rect: {\n          left: slatHit.left,\n          right: slatHit.right,\n          top: 0,\n          bottom: elHeight\n        },\n        dayEl: slatHit.dayEl,\n        layer: 0\n      };\n    }\n    return null;\n  }\n}\nclass TimelineView extends DateComponent {\n  constructor() {\n    super(...arguments);\n    this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n    this.scrollGridRef = createRef();\n    this.state = {\n      slatCoords: null,\n      slotCushionMaxWidth: null\n    };\n    this.handleSlatCoords = slatCoords => {\n      this.setState({\n        slatCoords\n      });\n    };\n    this.handleScrollLeftRequest = scrollLeft => {\n      let scrollGrid = this.scrollGridRef.current;\n      scrollGrid.forceScrollLeft(0, scrollLeft);\n    };\n    this.handleMaxCushionWidth = slotCushionMaxWidth => {\n      this.setState({\n        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth) // for less rerendering TODO: DRY\n      });\n    };\n  }\n\n  render() {\n    let {\n      props,\n      state,\n      context\n    } = this;\n    let {\n      options\n    } = context;\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n    let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n    let {\n      slotMinWidth\n    } = options;\n    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n    let sections = [{\n      type: 'header',\n      key: 'header',\n      isSticky: stickyHeaderDates,\n      chunks: [{\n        key: 'timeline',\n        content: contentArg => createElement(TimelineHeader, {\n          dateProfile: props.dateProfile,\n          clientWidth: contentArg.clientWidth,\n          clientHeight: contentArg.clientHeight,\n          tableMinWidth: contentArg.tableMinWidth,\n          tableColGroupNode: contentArg.tableColGroupNode,\n          tDateProfile: tDateProfile,\n          slatCoords: state.slatCoords,\n          onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth\n        })\n      }]\n    }, {\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'timeline',\n        content: contentArg => createElement(TimelineGrid, Object.assign({}, props, {\n          clientWidth: contentArg.clientWidth,\n          clientHeight: contentArg.clientHeight,\n          tableMinWidth: contentArg.tableMinWidth,\n          tableColGroupNode: contentArg.tableColGroupNode,\n          tDateProfile: tDateProfile,\n          onSlatCoords: this.handleSlatCoords,\n          onScrollLeftRequest: this.handleScrollLeftRequest\n        }))\n      }]\n    }];\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'timeline',\n          content: renderScrollShim\n        }]\n      });\n    }\n    return createElement(ViewContainer, {\n      elClasses: ['fc-timeline', options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : ''],\n      viewSpec: context.viewSpec\n    }, createElement(ScrollGrid, {\n      ref: this.scrollGridRef,\n      liquid: !props.isHeightAuto && !props.forPrint,\n      forPrint: props.forPrint,\n      collapsibleWidth: false,\n      colGroups: [{\n        cols: slatCols\n      }],\n      sections: sections\n    }));\n  }\n  computeFallbackSlotMinWidth(tDateProfile) {\n    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);\n  }\n}\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n  return [{\n    span: tDateProfile.slotCnt,\n    minWidth: slotMinWidth || 1 // needs to be a non-zero number to trigger horizontal scrollbars!??????\n  }];\n}\n\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };","map":{"version":3,"names":["injectStyles","config","createFormatter","greatestDurationDenominator","asCleanDays","createDuration","wholeDivideDurations","asRoughMs","addDays","startOfDay","asRoughSeconds","asRoughMinutes","diffWholeDays","isInt","computeVisibleDayRange","padStart","BaseComponent","memoizeObjArg","memoize","getDateMeta","ContentContainer","getSlotClassNames","getDayClassNames","buildNavLinkAttrs","PositionCache","findDirectChildren","rangeContainsMarker","NowTimer","NowIndicatorContainer","findElements","RefMap","multiplyDuration","SegHierarchy","groupIntersectingEntries","buildIsoString","computeEarliestSegStart","buildEventRangeKey","BgEvent","getSegMeta","renderFill","Slicer","intersectRanges","addMs","StandardEvent","MoreLinkContainer","sortEventSegs","mapHash","isPropsEqual","DateComponent","getStickyHeaderDates","getStickyFooterScrollbar","ViewContainer","renderScrollShim","createElement","Fragment","createRef","ScrollGrid","css_248z","MIN_AUTO_LABELS","MAX_AUTO_SLOTS_PER_LABEL","MAX_AUTO_CELLS","MAX_TIMELINE_SLOTS","STOCK_SUB_DURATIONS","years","months","days","hours","minutes","seconds","milliseconds","buildTimelineDateProfile","dateProfile","dateEnv","allOptions","dateProfileGenerator","tDateProfile","labelInterval","slotLabelInterval","slotDuration","validateLabelAndSlot","ensureLabelInterval","ensureSlotDuration","input","slotLabelFormat","rawFormats","Array","isArray","computeHeaderFormats","headerFormats","map","rawFormat","isTimeScale","Boolean","largeUnit","slotUnit","unit","test","emphasizeWeeks","currentRangeAs","businessHours","rawSnapDuration","snapDuration","snapsPerSlot","timeWindowMs","slotMaxTime","slotMinTime","normalizedStart","normalizeDate","renderRange","start","normalizedEnd","end","add","normalizedRange","slotDates","date","isValidDate","push","snapIndex","snapDiff","snapDiffToIndex","snapIndexToDiff","snapCnt","slotCnt","isWeekStarts","buildIsWeekStarts","cellRows","buildCellRows","slotsPerLabel","normalDate","startOf","normalizeRange","range","dayRange","valueOf","isHiddenDay","day","timeMs","ms","currentRange","labelCnt","countDurationsBetween","console","warn","tryLabelInterval","trySlotDuration","format1","format2","weekNumbersVisible","weekNumbers","format0","year","month","week","weekday","omitCommas","hour","minute","omitZeroMinute","meridiem","params","second","millisecond","concat","res","diffWholeYears","diffWholeMonths","prevWeekNumber","slotDate","weekNumber","computeWeekNumber","isWeekStart","formats","slotAsDays","guessedSlotUnit","rowUnitsFromFormats","format","getLargestUnit","i","length","row","rowCells","leadingCell","isLastRow","isSuperRow","newCell","rowUnit","text","buildCellObject","colspan","weekStart","TimelineHeaderTh","constructor","arguments","refineRenderProps","buildCellNavLinkAttrs","render","props","context","options","cell","dateMeta","todayRange","nowDate","renderProps","level","rowLevel","dateMarker","viewApi","elTag","elClasses","theme","elAttrs","colSpan","formatIso","omitTime","omitTimeZoneOffset","generatorName","customGenerator","slotLabelContent","defaultGenerator","renderInnerContent","classNameGenerator","slotLabelClassNames","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","InnerContent","className","style","height","rowInnerHeight","isSticky","cellDate","toDate","view","TimelineHeaderRows","rowInnerHeights","isLast","isChrono","classNames","key","join","toISOString","TimelineCoords","slatRootEl","slatEls","isRtl","outerCoordCache","innerCoordCache","isDateInRange","dateToCoord","snapCoverage","computeDateSnapCoverage","slotCoverage","slotIndex","Math","floor","min","partial","originClientRect","width","rights","getWidth","lefts","rangeToCoords","durationToCoord","duration","coord","activeRange","coordFromLeft","snapDiffInt","ceil","coordToCss","hcoord","left","right","coordsToCss","hcoords","TimelineHeader","rootElRef","timerUnit","slatCoords","ref","minWidth","tableMinWidth","clientWidth","tableColGroupNode","nowIndicator","elStyle","isAxis","componentDidMount","updateSize","componentDidUpdate","onMaxCushionWidth","computeMaxCushionWidth","max","current","el","getBoundingClientRect","TimelineSlatCell","isEm","Object","assign","elRef","isDay","slotLaneContent","slotLaneClassNames","slotLaneDidMount","slotLaneWillUnmount","TimelineSlatsBody","cellElRefs","TimelineSlats","handleScrollRequest","request","onScrollLeftRequest","coords","time","scrollLeft","getClass","updateSizing","scrollResponder","createScrollResponder","prevProps","update","componentWillUnmount","detach","onCoords","rootEl","offsetWidth","collectCellEls","currentMap","positionToHit","leftPosition","slatIndex","leftToIndex","slatWidth","localSnapIndex","dateSpan","allDay","dayEl","elMap","computeSegHCoords","segs","timelineCoords","seg","round","computeFgSegPlacements","segHCoords","eventInstanceHeights","moreLinkHeights","strictOrder","maxStackCnt","segInputs","crudePlacements","instanceId","eventRange","instance","index","span","thickness","top","hierarchy","hiddenEntries","addSegs","hiddenPlacements","entry","hiddenGroups","moreLinkInputs","moreLinkCrudePlacements","extractSeg","hiddenGroup","sortedSegs","entries","visibleRects","toRects","visiblePlacements","maxHeight","rect","segIndex","levelCoord","TimelineLaneBg","highlightSeg","eventResizeSegs","dateSelectionSegs","renderSegs","businessHourSegs","bgEventSegs","fillType","children","hStyle","TimelineLaneSlicer","sliceRange","origRange","normalRange","slicedRange","isStart","isEnd","DEFAULT_TIME_FORMAT","TimelineEvent","defaultTimeFormat","defaultDisplayEventTime","TimelineLaneMoreLink","hiddenSegs","placement","resourceId","isVisible","extraDateSpan","visibility","allDayDate","moreCnt","allSegs","popoverContent","isForcedInvisible","isDragging","isResizing","isDateSelecting","isSelected","eventSelection","TimelineLane","slicer","harnessElRefs","moreElRefs","innerElRef","state","handleResize","isForced","slicedProps","sliceProps","nextDayThreshold","mirrorSegs","eventDrag","eventResize","fgSegs","fgEventSegs","eventOrder","fgSegHCoords","eventMinWidth","fgPlacements","fgHeight","eventOrderStrict","eventMaxStack","affectedInstances","renderFgSegs","buildMirrorPlacements","addResizeHandler","prevState","eventStore","removeResizeHandler","innerEl","onHeightChange","setState","harnessEl","moreEl","syncParentMinHeight","parentElement","minHeight","segPlacements","isMirror","segPlacement","isoStr","addStateEquality","topsByInstanceId","buildAbsoluteTopHash","placements","TimelineGrid","slatsRef","handeEl","registerInteractiveComponent","unregisterInteractiveComponent","handleCoords","onSlatCoords","clientHeight","eventUiBases","dateSelection","queryHit","positionLeft","positionTop","elWidth","elHeight","slats","slatHit","bottom","layer","TimelineView","scrollGridRef","slotCushionMaxWidth","handleSlatCoords","handleScrollLeftRequest","scrollGrid","forceScrollLeft","handleMaxCushionWidth","stickyHeaderDates","forPrint","stickyFooterScrollbar","slotMinWidth","slatCols","buildSlatCols","computeFallbackSlotMinWidth","sections","type","chunks","content","contentArg","liquid","eventOverlap","viewSpec","isHeightAuto","collapsibleWidth","colGroups","cols"],"sources":["C:/Users/erden/Videos/FInals/New folder/streamlit-calendar/streamlit_calendar/frontend/node_modules/@fullcalendar/timeline/internal.js"],"sourcesContent":["import { injectStyles, config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, BaseComponent, memoizeObjArg, memoize, getDateMeta, ContentContainer, getSlotClassNames, getDayClassNames, buildNavLinkAttrs, PositionCache, findDirectChildren, rangeContainsMarker, NowTimer, NowIndicatorContainer, findElements, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, Slicer, intersectRanges, addMs, StandardEvent, MoreLinkContainer, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewContainer, renderScrollShim } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment, createRef } from '@fullcalendar/core/preact.js';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid/internal.js';\n\nvar css_248z = \".fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:\\\"\\\";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}\";\ninjectStyles(css_248z);\n\nconst MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\nconst MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\nconst MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000;\n// potential nice values for slot-duration and interval-duration\nconst STOCK_SUB_DURATIONS = [\n    { years: 1 },\n    { months: 1 },\n    { days: 1 },\n    { hours: 1 },\n    { minutes: 30 },\n    { minutes: 15 },\n    { minutes: 10 },\n    { minutes: 5 },\n    { minutes: 1 },\n    { seconds: 30 },\n    { seconds: 15 },\n    { seconds: 10 },\n    { seconds: 5 },\n    { seconds: 1 },\n    { milliseconds: 500 },\n    { milliseconds: 100 },\n    { milliseconds: 10 },\n    { milliseconds: 1 },\n];\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n    let tDateProfile = {\n        labelInterval: allOptions.slotLabelInterval,\n        slotDuration: allOptions.slotDuration,\n    };\n    validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n    ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n    ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n    let input = allOptions.slotLabelFormat;\n    let rawFormats = Array.isArray(input) ? input :\n        (input != null) ? [input] :\n            computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n    tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat));\n    tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n    let largeUnit = null;\n    if (!tDateProfile.isTimeScale) {\n        const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n        if (/year|month|week/.test(slotUnit)) {\n            largeUnit = slotUnit;\n        }\n    }\n    tDateProfile.largeUnit = largeUnit;\n    tDateProfile.emphasizeWeeks =\n        asCleanDays(tDateProfile.slotDuration) === 1 &&\n            currentRangeAs('weeks', dateProfile, dateEnv) >= 2 &&\n            !allOptions.businessHours;\n    /*\n    console.log('label interval =', timelineView.labelInterval.humanize())\n    console.log('slot duration =', timelineView.slotDuration.humanize())\n    console.log('header formats =', timelineView.headerFormats)\n    console.log('isTimeScale', timelineView.isTimeScale)\n    console.log('largeUnit', timelineView.largeUnit)\n    */\n    let rawSnapDuration = allOptions.snapDuration;\n    let snapDuration;\n    let snapsPerSlot;\n    if (rawSnapDuration) {\n        snapDuration = createDuration(rawSnapDuration);\n        snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);\n        // ^ TODO: warning if not whole?\n    }\n    if (snapsPerSlot == null) {\n        snapDuration = tDateProfile.slotDuration;\n        snapsPerSlot = 1;\n    }\n    tDateProfile.snapDuration = snapDuration;\n    tDateProfile.snapsPerSlot = snapsPerSlot;\n    // more...\n    let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);\n    // TODO: why not use normalizeRange!?\n    let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n    let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);\n    // apply slotMinTime/slotMaxTime\n    // TODO: View should be responsible.\n    if (tDateProfile.isTimeScale) {\n        normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n        normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n    }\n    tDateProfile.timeWindowMs = timeWindowMs;\n    tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd };\n    let slotDates = [];\n    let date = normalizedStart;\n    while (date < normalizedEnd) {\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n            slotDates.push(date);\n        }\n        date = dateEnv.add(date, tDateProfile.slotDuration);\n    }\n    tDateProfile.slotDates = slotDates;\n    // more...\n    let snapIndex = -1;\n    let snapDiff = 0; // index of the diff :(\n    const snapDiffToIndex = [];\n    const snapIndexToDiff = [];\n    date = normalizedStart;\n    while (date < normalizedEnd) {\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n            snapIndex += 1;\n            snapDiffToIndex.push(snapIndex);\n            snapIndexToDiff.push(snapDiff);\n        }\n        else {\n            snapDiffToIndex.push(snapIndex + 0.5);\n        }\n        date = dateEnv.add(date, tDateProfile.snapDuration);\n        snapDiff += 1;\n    }\n    tDateProfile.snapDiffToIndex = snapDiffToIndex;\n    tDateProfile.snapIndexToDiff = snapIndexToDiff;\n    tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n    tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;\n    // more...\n    tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n    tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n    tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n    return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n    let normalDate = date;\n    if (!tDateProfile.isTimeScale) {\n        normalDate = startOfDay(normalDate);\n        if (tDateProfile.largeUnit) {\n            normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n        }\n    }\n    return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n    if (!tDateProfile.isTimeScale) {\n        range = computeVisibleDayRange(range);\n        if (tDateProfile.largeUnit) {\n            let dayRange = range; // preserve original result\n            range = {\n                start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n                end: dateEnv.startOf(range.end, tDateProfile.largeUnit),\n            };\n            // if date is partially through the interval, or is in the same interval as the start,\n            // make the exclusive end be the *next* interval\n            if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n                range = {\n                    start: range.start,\n                    end: dateEnv.add(range.end, tDateProfile.slotDuration),\n                };\n            }\n        }\n    }\n    return range;\n}\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n    if (dateProfileGenerator.isHiddenDay(date)) {\n        return false;\n    }\n    if (tDateProfile.isTimeScale) {\n        // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n        let day = startOfDay(date);\n        let timeMs = date.valueOf() - day.valueOf();\n        let ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n        ms = ((ms % 86400000) + 86400000) % 86400000; // make negative values wrap to 24hr clock\n        return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n    }\n    return true;\n}\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    // make sure labelInterval doesn't exceed the max number of cells\n    if (tDateProfile.labelInterval) {\n        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n        if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n            console.warn('slotLabelInterval results in too many cells');\n            tDateProfile.labelInterval = null;\n        }\n    }\n    // make sure slotDuration doesn't exceed the maximum number of cells\n    if (tDateProfile.slotDuration) {\n        const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n        if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n            console.warn('slotDuration results in too many cells');\n            tDateProfile.slotDuration = null;\n        }\n    }\n    // make sure labelInterval is a multiple of slotDuration\n    if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n        const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n        if (slotsPerLabel === null || slotsPerLabel < 1) {\n            console.warn('slotLabelInterval must be a multiple of slotDuration');\n            tDateProfile.slotDuration = null;\n        }\n    }\n}\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    let { labelInterval } = tDateProfile;\n    if (!labelInterval) {\n        // compute based off the slot duration\n        // find the largest label interval with an acceptable slots-per-label\n        let input;\n        if (tDateProfile.slotDuration) {\n            for (input of STOCK_SUB_DURATIONS) {\n                const tryLabelInterval = createDuration(input);\n                const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n                if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n                    labelInterval = tryLabelInterval;\n                    break;\n                }\n            }\n            // use the slot duration as a last resort\n            if (!labelInterval) {\n                labelInterval = tDateProfile.slotDuration;\n            }\n            // compute based off the view's duration\n            // find the largest label interval that yields the minimum number of labels\n        }\n        else {\n            for (input of STOCK_SUB_DURATIONS) {\n                labelInterval = createDuration(input);\n                const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n                if (labelCnt >= MIN_AUTO_LABELS) {\n                    break;\n                }\n            }\n        }\n        tDateProfile.labelInterval = labelInterval;\n    }\n    return labelInterval;\n}\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    let { slotDuration } = tDateProfile;\n    if (!slotDuration) {\n        const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n        // compute based off the label interval\n        // find the largest slot duration that is different from labelInterval, but still acceptable\n        for (let input of STOCK_SUB_DURATIONS) {\n            const trySlotDuration = createDuration(input);\n            const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n            if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n                slotDuration = trySlotDuration;\n                break;\n            }\n        }\n        // only allow the value if it won't exceed the view's # of slots limit\n        if (slotDuration) {\n            const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n            if (slotCnt > MAX_AUTO_CELLS) {\n                slotDuration = null;\n            }\n        }\n        // use the label interval as a last resort\n        if (!slotDuration) {\n            slotDuration = labelInterval;\n        }\n        tDateProfile.slotDuration = slotDuration;\n    }\n    return slotDuration;\n}\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n    let format1;\n    let format2;\n    const { labelInterval } = tDateProfile;\n    let unit = greatestDurationDenominator(labelInterval).unit;\n    const weekNumbersVisible = allOptions.weekNumbers;\n    let format0 = (format1 = (format2 = null));\n    // NOTE: weekNumber computation function wont work\n    if ((unit === 'week') && !weekNumbersVisible) {\n        unit = 'day';\n    }\n    switch (unit) {\n        case 'year':\n            format0 = { year: 'numeric' }; // '2015'\n            break;\n        case 'month':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric' }; // '2015'\n            }\n            format1 = { month: 'short' }; // 'Jan'\n            break;\n        case 'week':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric' }; // '2015'\n            }\n            format1 = { week: 'narrow' }; // 'Wk4'\n            break;\n        case 'day':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric', month: 'long' }; // 'January 2014'\n            }\n            else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n                format0 = { month: 'long' }; // 'January'\n            }\n            if (weekNumbersVisible) {\n                format1 = { week: 'short' }; // 'Wk 4'\n            }\n            format2 = { weekday: 'narrow', day: 'numeric' }; // 'Su 9'\n            break;\n        case 'hour':\n            if (weekNumbersVisible) {\n                format0 = { week: 'short' }; // 'Wk 4'\n            }\n            if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n                format1 = { weekday: 'short', day: 'numeric', month: 'numeric', omitCommas: true }; // Sat 4/7\n            }\n            format2 = {\n                hour: 'numeric',\n                minute: '2-digit',\n                omitZeroMinute: true,\n                meridiem: 'short',\n            };\n            break;\n        case 'minute':\n            // sufficiently large number of different minute cells?\n            if ((asRoughMinutes(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                format0 = {\n                    hour: 'numeric',\n                    meridiem: 'short',\n                };\n                format1 = (params) => (':' + padStart(params.date.minute, 2) // ':30'\n                );\n            }\n            else {\n                format0 = {\n                    hour: 'numeric',\n                    minute: 'numeric',\n                    meridiem: 'short',\n                };\n            }\n            break;\n        case 'second':\n            // sufficiently large number of different second cells?\n            if ((asRoughSeconds(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                format0 = { hour: 'numeric', minute: '2-digit', meridiem: 'lowercase' }; // '8:30 PM'\n                format1 = (params) => (':' + padStart(params.date.second, 2) // ':30'\n                );\n            }\n            else {\n                format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\n            }\n            break;\n        case 'millisecond':\n            format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\n            format1 = (params) => ('.' + padStart(params.millisecond, 3));\n            break;\n    }\n    return [].concat(format0 || [], format1 || [], format2 || []);\n}\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n    let range = dateProfile.currentRange;\n    let res = null;\n    if (unit === 'years') {\n        res = dateEnv.diffWholeYears(range.start, range.end);\n    }\n    else if (unit === 'months') {\n        res = dateEnv.diffWholeMonths(range.start, range.end);\n    }\n    else if (unit === 'weeks') {\n        res = dateEnv.diffWholeMonths(range.start, range.end);\n    }\n    else if (unit === 'days') {\n        res = diffWholeDays(range.start, range.end);\n    }\n    return res || 0;\n}\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n    let { slotDates, emphasizeWeeks } = tDateProfile;\n    let prevWeekNumber = null;\n    let isWeekStarts = [];\n    for (let slotDate of slotDates) {\n        let weekNumber = dateEnv.computeWeekNumber(slotDate);\n        let isWeekStart = emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber);\n        prevWeekNumber = weekNumber;\n        isWeekStarts.push(isWeekStart);\n    }\n    return isWeekStarts;\n}\nfunction buildCellRows(tDateProfile, dateEnv) {\n    let slotDates = tDateProfile.slotDates;\n    let formats = tDateProfile.headerFormats;\n    let cellRows = formats.map(() => []); // indexed by row,col\n    let slotAsDays = asCleanDays(tDateProfile.slotDuration);\n    let guessedSlotUnit = slotAsDays === 7 ? 'week' :\n        slotAsDays === 1 ? 'day' :\n            null;\n    // specifically for navclicks\n    let rowUnitsFromFormats = formats.map((format) => (format.getLargestUnit ? format.getLargestUnit() : null));\n    // builds cellRows and slotCells\n    for (let i = 0; i < slotDates.length; i += 1) {\n        let date = slotDates[i];\n        let isWeekStart = tDateProfile.isWeekStarts[i];\n        for (let row = 0; row < formats.length; row += 1) {\n            let format = formats[row];\n            let rowCells = cellRows[row];\n            let leadingCell = rowCells[rowCells.length - 1];\n            let isLastRow = row === formats.length - 1;\n            let isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n            let newCell = null;\n            let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n            if (isSuperRow) {\n                let text = dateEnv.format(date, format);\n                if (!leadingCell || (leadingCell.text !== text)) {\n                    newCell = buildCellObject(date, text, rowUnit);\n                }\n                else {\n                    leadingCell.colspan += 1;\n                }\n            }\n            else if (!leadingCell ||\n                isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n                let text = dateEnv.format(date, format);\n                newCell = buildCellObject(date, text, rowUnit);\n            }\n            else {\n                leadingCell.colspan += 1;\n            }\n            if (newCell) {\n                newCell.weekStart = isWeekStart;\n                rowCells.push(newCell);\n            }\n        }\n    }\n    return cellRows;\n}\nfunction buildCellObject(date, text, rowUnit) {\n    return { date, text, rowUnit, colspan: 1, isWeekStart: false };\n}\n\nclass TimelineHeaderTh extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n        this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n    }\n    render() {\n        let { props, context } = this;\n        let { dateEnv, options } = context;\n        let { cell, dateProfile, tDateProfile } = props;\n        // the cell.rowUnit is f'd\n        // giving 'month' for a 3-day view\n        // workaround: to infer day, do NOT time\n        let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n        let renderProps = this.refineRenderProps({\n            level: props.rowLevel,\n            dateMarker: cell.date,\n            text: cell.text,\n            dateEnv: context.dateEnv,\n            viewApi: context.viewApi,\n        });\n        return (createElement(ContentContainer, { elTag: \"th\", elClasses: [\n                'fc-timeline-slot',\n                'fc-timeline-slot-label',\n                cell.isWeekStart && 'fc-timeline-slot-em',\n                ...( // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n                cell.rowUnit === 'time' ?\n                    getSlotClassNames(dateMeta, context.theme) :\n                    getDayClassNames(dateMeta, context.theme)),\n            ], elAttrs: {\n                colSpan: cell.colspan,\n                'data-date': dateEnv.formatIso(cell.date, {\n                    omitTime: !tDateProfile.isTimeScale,\n                    omitTimeZoneOffset: true,\n                }),\n            }, renderProps: renderProps, generatorName: \"slotLabelContent\", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => (createElement(\"div\", { className: \"fc-timeline-slot-frame\", style: { height: props.rowInnerHeight } },\n            createElement(InnerContent, { elTag: \"a\", elClasses: [\n                    'fc-timeline-slot-cushion',\n                    'fc-scrollgrid-sync-inner',\n                    props.isSticky && 'fc-sticky',\n                ], elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit) })))));\n    }\n}\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n    return (rowUnit && rowUnit !== 'time')\n        ? buildNavLinkAttrs(context, cellDate, rowUnit)\n        : {};\n}\nfunction renderInnerContent(renderProps) {\n    return renderProps.text;\n}\nfunction refineRenderProps(input) {\n    return {\n        level: input.level,\n        date: input.dateEnv.toDate(input.dateMarker),\n        view: input.viewApi,\n        text: input.text,\n    };\n}\n\nclass TimelineHeaderRows extends BaseComponent {\n    render() {\n        let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props;\n        let { cellRows } = tDateProfile;\n        return (createElement(Fragment, null, cellRows.map((rowCells, rowLevel) => {\n            let isLast = rowLevel === cellRows.length - 1;\n            let isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n            let classNames = [\n                'fc-timeline-header-row',\n                isChrono ? 'fc-timeline-header-row-chrono' : '',\n            ];\n            return ( // eslint-disable-next-line react/no-array-index-key\n            createElement(\"tr\", { key: rowLevel, className: classNames.join(' ') }, rowCells.map((cell) => (createElement(TimelineHeaderTh, { key: cell.date.toISOString(), cell: cell, rowLevel: rowLevel, dateProfile: dateProfile, tDateProfile: tDateProfile, todayRange: todayRange, nowDate: nowDate, rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel], isSticky: !isLast })))));\n        })));\n    }\n}\n\nclass TimelineCoords {\n    constructor(slatRootEl, // okay to expose?\n    slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n        this.slatRootEl = slatRootEl;\n        this.dateProfile = dateProfile;\n        this.tDateProfile = tDateProfile;\n        this.dateEnv = dateEnv;\n        this.isRtl = isRtl;\n        this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal\n        false);\n        // for the inner divs within the slats\n        // used for event rendering and scrollTime, to disregard slat border\n        this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal\n        false);\n    }\n    isDateInRange(date) {\n        return rangeContainsMarker(this.dateProfile.currentRange, date);\n    }\n    // results range from negative width of area to 0\n    dateToCoord(date) {\n        let { tDateProfile } = this;\n        let snapCoverage = this.computeDateSnapCoverage(date);\n        let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n        let slotIndex = Math.floor(slotCoverage);\n        slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n        let partial = slotCoverage - slotIndex;\n        let { innerCoordCache, outerCoordCache } = this;\n        if (this.isRtl) {\n            return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] -\n                (innerCoordCache.getWidth(slotIndex) * partial));\n        }\n        return (outerCoordCache.lefts[slotIndex] +\n            (innerCoordCache.getWidth(slotIndex) * partial));\n    }\n    rangeToCoords(range) {\n        return {\n            start: this.dateToCoord(range.start),\n            end: this.dateToCoord(range.end),\n        };\n    }\n    durationToCoord(duration) {\n        let { dateProfile, tDateProfile, dateEnv, isRtl } = this;\n        let coord = 0;\n        if (dateProfile) {\n            let date = dateEnv.add(dateProfile.activeRange.start, duration);\n            if (!tDateProfile.isTimeScale) {\n                date = startOfDay(date);\n            }\n            coord = this.dateToCoord(date);\n            // hack to overcome the left borders of non-first slat\n            if (!isRtl && coord) {\n                coord += 1;\n            }\n        }\n        return coord;\n    }\n    coordFromLeft(coord) {\n        if (this.isRtl) {\n            return this.outerCoordCache.originClientRect.width - coord;\n        }\n        return coord;\n    }\n    // returned value is between 0 and the number of snaps\n    computeDateSnapCoverage(date) {\n        return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n    }\n}\n// returned value is between 0 and the number of snaps\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n    let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n    if (snapDiff < 0) {\n        return 0;\n    }\n    if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n        return tDateProfile.snapCnt;\n    }\n    let snapDiffInt = Math.floor(snapDiff);\n    let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n    if (isInt(snapCoverage)) { // not an in-between value\n        snapCoverage += snapDiff - snapDiffInt; // add the remainder\n    }\n    else {\n        // a fractional value, meaning the date is not visible\n        // always round up in this case. works for start AND end dates in a range.\n        snapCoverage = Math.ceil(snapCoverage);\n    }\n    return snapCoverage;\n}\nfunction coordToCss(hcoord, isRtl) {\n    if (hcoord === null) {\n        return { left: '', right: '' };\n    }\n    if (isRtl) {\n        return { right: hcoord, left: '' };\n    }\n    return { left: hcoord, right: '' };\n}\nfunction coordsToCss(hcoords, isRtl) {\n    if (!hcoords) {\n        return { left: '', right: '' };\n    }\n    if (isRtl) {\n        return { right: hcoords.start, left: -hcoords.end };\n    }\n    return { left: hcoords.start, right: -hcoords.end };\n}\n\nclass TimelineHeader extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n    }\n    render() {\n        let { props, context } = this;\n        // TODO: very repetitive\n        // TODO: make part of tDateProfile?\n        let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;\n        // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n        let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n        return (createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(\"div\", { className: \"fc-timeline-header\", ref: this.rootElRef },\n            createElement(\"table\", { \"aria-hidden\": true, className: \"fc-scrollgrid-sync-table\", style: { minWidth: props.tableMinWidth, width: props.clientWidth } },\n                props.tableColGroupNode,\n                createElement(\"tbody\", null,\n                    createElement(TimelineHeaderRows, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, rowInnerHeights: props.rowInnerHeights }))),\n            context.options.nowIndicator && (\n            // need to have a container regardless of whether the current view has a visible now indicator\n            // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n            // this issue doesn't happen for the timeline body however (\n            createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" }, (slatCoords && slatCoords.isDateInRange(nowDate)) && (createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-arrow'], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: true, date: nowDate }))))))));\n    }\n    componentDidMount() {\n        this.updateSize();\n    }\n    componentDidUpdate() {\n        this.updateSize();\n    }\n    updateSize() {\n        if (this.props.onMaxCushionWidth) {\n            this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n        }\n    }\n    computeMaxCushionWidth() {\n        return Math.max(...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map((el) => el.getBoundingClientRect().width));\n    }\n}\n\nclass TimelineSlatCell extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { dateEnv, options, theme } = context;\n        let { date, tDateProfile, isEm } = props;\n        let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n        let renderProps = Object.assign(Object.assign({ date: dateEnv.toDate(props.date) }, dateMeta), { view: context.viewApi });\n        return (createElement(ContentContainer, { elTag: \"td\", elRef: props.elRef, elClasses: [\n                'fc-timeline-slot',\n                'fc-timeline-slot-lane',\n                isEm && 'fc-timeline-slot-em',\n                tDateProfile.isTimeScale ? (isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ?\n                    'fc-timeline-slot-major' :\n                    'fc-timeline-slot-minor') : '',\n                ...(props.isDay ?\n                    getDayClassNames(dateMeta, theme) :\n                    getSlotClassNames(dateMeta, theme)),\n            ], elAttrs: {\n                'data-date': dateEnv.formatIso(date, {\n                    omitTimeZoneOffset: true,\n                    omitTime: !tDateProfile.isTimeScale,\n                }),\n            }, renderProps: renderProps, generatorName: \"slotLaneContent\", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\" }))));\n    }\n}\n\nclass TimelineSlatsBody extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { tDateProfile, cellElRefs } = props;\n        let { slotDates, isWeekStarts } = tDateProfile;\n        let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n        return (createElement(\"tbody\", null,\n            createElement(\"tr\", null, slotDates.map((slotDate, i) => {\n                let key = slotDate.toISOString();\n                return (createElement(TimelineSlatCell, { key: key, elRef: cellElRefs.createRef(key), date: slotDate, dateProfile: props.dateProfile, tDateProfile: tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isEm: isWeekStarts[i], isDay: isDay }));\n            }))));\n    }\n}\n\nclass TimelineSlats extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n        this.cellElRefs = new RefMap();\n        this.handleScrollRequest = (request) => {\n            let { onScrollLeftRequest } = this.props;\n            let { coords } = this;\n            if (onScrollLeftRequest && coords) {\n                if (request.time) {\n                    let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n                    onScrollLeftRequest(scrollLeft);\n                }\n                return true;\n            }\n            return null; // best?\n        };\n    }\n    render() {\n        let { props, context } = this;\n        return (createElement(\"div\", { className: \"fc-timeline-slots\", ref: this.rootElRef },\n            createElement(\"table\", { \"aria-hidden\": true, className: context.theme.getClass('table'), style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                } },\n                props.tableColGroupNode,\n                createElement(TimelineSlatsBody, { cellElRefs: this.cellElRefs, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange }))));\n    }\n    componentDidMount() {\n        this.updateSizing();\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n    componentDidUpdate(prevProps) {\n        this.updateSizing();\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n    componentWillUnmount() {\n        this.scrollResponder.detach();\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    }\n    updateSizing() {\n        let { props, context } = this;\n        if (props.clientWidth !== null && // is sizing stable?\n            this.scrollResponder\n        // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n        ) {\n            let rootEl = this.rootElRef.current;\n            if (rootEl.offsetWidth) { // not hidden by css\n                this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n                if (props.onCoords) {\n                    props.onCoords(this.coords);\n                }\n                this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n            }\n        }\n    }\n    positionToHit(leftPosition) {\n        let { outerCoordCache } = this.coords;\n        let { dateEnv, isRtl } = this.context;\n        let { tDateProfile } = this.props;\n        let slatIndex = outerCoordCache.leftToIndex(leftPosition);\n        if (slatIndex != null) {\n            // somewhat similar to what TimeGrid does. consolidate?\n            let slatWidth = outerCoordCache.getWidth(slatIndex);\n            let partial = isRtl ?\n                (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth :\n                (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n            let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n            let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n            let end = dateEnv.add(start, tDateProfile.snapDuration);\n            return {\n                dateSpan: {\n                    range: { start, end },\n                    allDay: !this.props.tDateProfile.isTimeScale,\n                },\n                dayEl: this.cellElRefs.currentMap[slatIndex],\n                left: outerCoordCache.lefts[slatIndex],\n                right: outerCoordCache.rights[slatIndex],\n            };\n        }\n        return null;\n    }\n}\nfunction collectCellEls(elMap, slotDates) {\n    return slotDates.map((slotDate) => {\n        let key = slotDate.toISOString();\n        return elMap[key];\n    });\n}\n\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n    let hcoords = [];\n    if (timelineCoords) {\n        for (let seg of segs) {\n            let res = timelineCoords.rangeToCoords(seg);\n            let start = Math.round(res.start); // for barely-overlapping collisions\n            let end = Math.round(res.end); //\n            if (end - start < minWidth) {\n                end = start + minWidth;\n            }\n            hcoords.push({ start, end });\n        }\n    }\n    return hcoords;\n}\nfunction computeFgSegPlacements(segs, segHCoords, // might not have for every seg\neventInstanceHeights, // might not have for every seg\nmoreLinkHeights, // might not have for every more-link\nstrictOrder, maxStackCnt) {\n    let segInputs = [];\n    let crudePlacements = []; // when we don't know dims\n    for (let i = 0; i < segs.length; i += 1) {\n        let seg = segs[i];\n        let instanceId = seg.eventRange.instance.instanceId;\n        let height = eventInstanceHeights[instanceId];\n        let hcoords = segHCoords[i];\n        if (height && hcoords) {\n            segInputs.push({\n                index: i,\n                span: hcoords,\n                thickness: height,\n            });\n        }\n        else {\n            crudePlacements.push({\n                seg,\n                hcoords,\n                top: null,\n            });\n        }\n    }\n    let hierarchy = new SegHierarchy();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let hiddenPlacements = hiddenEntries.map((entry) => ({\n        seg: segs[entry.index],\n        hcoords: entry.span,\n        top: null,\n    }));\n    let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n    let moreLinkInputs = [];\n    let moreLinkCrudePlacements = [];\n    const extractSeg = (entry) => segs[entry.index];\n    for (let i = 0; i < hiddenGroups.length; i += 1) {\n        let hiddenGroup = hiddenGroups[i];\n        let sortedSegs = hiddenGroup.entries.map(extractSeg);\n        let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n        if (height != null) {\n            // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n            moreLinkInputs.push({\n                index: segs.length + i,\n                thickness: height,\n                span: hiddenGroup.span,\n            });\n        }\n        else {\n            moreLinkCrudePlacements.push({\n                seg: sortedSegs,\n                hcoords: hiddenGroup.span,\n                top: null,\n            });\n        }\n    }\n    // add more-links into the hierarchy, but don't limit\n    hierarchy.maxStackCnt = -1;\n    hierarchy.addSegs(moreLinkInputs);\n    let visibleRects = hierarchy.toRects();\n    let visiblePlacements = [];\n    let maxHeight = 0;\n    for (let rect of visibleRects) {\n        let segIndex = rect.index;\n        visiblePlacements.push({\n            seg: segIndex < segs.length\n                ? segs[segIndex] // a real seg\n                : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n            hcoords: rect.span,\n            top: rect.levelCoord,\n        });\n        maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n    }\n    return [\n        visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),\n        maxHeight,\n    ];\n}\n\nclass TimelineLaneBg extends BaseComponent {\n    render() {\n        let { props } = this;\n        let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n        return props.timelineCoords && (createElement(\"div\", { className: \"fc-timeline-bg\" },\n            this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'),\n            this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'),\n            this.renderSegs(highlightSeg, props.timelineCoords, 'highlight')));\n    }\n    renderSegs(segs, timelineCoords, fillType) {\n        let { todayRange, nowDate } = this.props;\n        let { isRtl } = this.context;\n        let segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n        let children = segs.map((seg, i) => {\n            let hcoords = segHCoords[i];\n            let hStyle = coordsToCss(hcoords, isRtl);\n            return (createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-timeline-bg-harness\", style: hStyle }, fillType === 'bg-event' ?\n                createElement(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, todayRange, nowDate))) :\n                renderFill(fillType)));\n        });\n        return createElement(Fragment, null, children);\n    }\n}\n\nclass TimelineLaneSlicer extends Slicer {\n    sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n        let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n        let segs = [];\n        // protect against when the span is entirely in an invalid date region\n        if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv)\n            < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n            // intersect the footprint's range with the grid's range\n            let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n            if (slicedRange) {\n                segs.push({\n                    start: slicedRange.start,\n                    end: slicedRange.end,\n                    isStart: slicedRange.start.valueOf() === normalRange.start.valueOf()\n                        && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n                    isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf()\n                        && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator),\n                });\n            }\n        }\n        return segs;\n    }\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n    hour: 'numeric',\n    minute: '2-digit',\n    omitZeroMinute: true,\n    meridiem: 'narrow',\n});\nclass TimelineEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        return (createElement(StandardEvent, Object.assign({}, props, { elClasses: ['fc-timeline-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TIME_FORMAT, defaultDisplayEventTime: !props.isTimeScale })));\n    }\n}\n\nclass TimelineLaneMoreLink extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { hiddenSegs, placement, resourceId } = props;\n        let { top, hcoords } = placement;\n        let isVisible = hcoords && top !== null;\n        let hStyle = coordsToCss(hcoords, context.isRtl);\n        let extraDateSpan = resourceId ? { resourceId } : {};\n        return (createElement(MoreLinkContainer, { elRef: props.elRef, elClasses: ['fc-timeline-more-link'], elStyle: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle), allDayDate: null, moreCnt: hiddenSegs.length, allSegs: hiddenSegs, hiddenSegs: hiddenSegs, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: extraDateSpan, popoverContent: () => (createElement(Fragment, null, hiddenSegs.map((seg) => {\n                let instanceId = seg.eventRange.instance.instanceId;\n                return (createElement(\"div\", { key: instanceId, style: { visibility: props.isForcedInvisible[instanceId] ? 'hidden' : '' } },\n                    createElement(TimelineEvent, Object.assign({ isTimeScale: props.isTimeScale, seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n            }))) }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\", elClasses: ['fc-timeline-more-link-inner', 'fc-sticky'] }))));\n    }\n}\n\nclass TimelineLane extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.slicer = new TimelineLaneSlicer();\n        this.sortEventSegs = memoize(sortEventSegs);\n        this.harnessElRefs = new RefMap();\n        this.moreElRefs = new RefMap();\n        this.innerElRef = createRef();\n        // TODO: memoize event positioning\n        this.state = {\n            eventInstanceHeights: {},\n            moreLinkHeights: {},\n        };\n        this.handleResize = (isForced) => {\n            if (isForced) {\n                this.updateSize();\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let { dateProfile, tDateProfile } = props;\n        let slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...\n        dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n        let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) ||\n            (slicedProps.eventResize ? slicedProps.eventResize.segs : null) ||\n            [];\n        let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n        let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n        let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);\n        let isForcedInvisible = // TODO: more convenient\n         (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) ||\n            (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) ||\n            {};\n        return (createElement(Fragment, null,\n            createElement(TimelineLaneBg, { businessHourSegs: slicedProps.businessHourSegs, bgEventSegs: slicedProps.bgEventSegs, timelineCoords: props.timelineCoords, eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [] /* bad new empty array? */, dateSelectionSegs: slicedProps.dateSelectionSegs, nowDate: props.nowDate, todayRange: props.todayRange }),\n            createElement(\"div\", { className: \"fc-timeline-events fc-scrollgrid-sync-inner\", ref: this.innerElRef, style: { height: fgHeight } },\n                this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false),\n                this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false))));\n    }\n    componentDidMount() {\n        this.updateSize();\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        if (prevProps.eventStore !== this.props.eventStore || // external thing changed?\n            prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n            prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n        ) {\n            this.updateSize();\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateSize() {\n        let { props } = this;\n        let { timelineCoords } = props;\n        const innerEl = this.innerElRef.current;\n        if (props.onHeightChange) {\n            props.onHeightChange(innerEl, false);\n        }\n        if (timelineCoords) {\n            this.setState({\n                eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => (Math.round(harnessEl.getBoundingClientRect().height))),\n                moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => (Math.round(moreEl.getBoundingClientRect().height))),\n            }, () => {\n                if (props.onHeightChange) {\n                    props.onHeightChange(innerEl, true);\n                }\n            });\n        }\n        // hack\n        if (props.syncParentMinHeight) {\n            innerEl.parentElement.style.minHeight = innerEl.style.height;\n        }\n    }\n    renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { harnessElRefs, moreElRefs, props, context } = this;\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        return (createElement(Fragment, null, segPlacements.map((segPlacement) => {\n            let { seg, hcoords, top } = segPlacement;\n            if (Array.isArray(seg)) { // a more-link\n                let isoStr = buildIsoString(computeEarliestSegStart(seg));\n                return (createElement(TimelineLaneMoreLink, { key: 'm:' + isoStr /* \"m\" for \"more\" */, elRef: moreElRefs.createRef(isoStr), hiddenSegs: seg, placement: segPlacement, dateProfile: props.dateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isTimeScale: props.tDateProfile.isTimeScale, eventSelection: props.eventSelection, resourceId: props.resourceId, isForcedInvisible: isForcedInvisible }));\n            }\n            let instanceId = seg.eventRange.instance.instanceId;\n            let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n            let hStyle = coordsToCss(hcoords, context.isRtl);\n            return (createElement(\"div\", { key: 'e:' + instanceId /* \"e\" for \"event\" */, ref: isMirror ? null : harnessElRefs.createRef(instanceId), className: \"fc-timeline-event-harness\", style: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle) },\n                createElement(TimelineEvent, Object.assign({ isTimeScale: props.tDateProfile.isTimeScale, seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === props.eventSelection /* TODO: bad for mirror? */ }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n        })));\n    }\n}\nTimelineLane.addStateEquality({\n    eventInstanceHeights: isPropsEqual,\n    moreLinkHeights: isPropsEqual,\n});\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n    if (!mirrorSegs.length || !timelineCoords) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg) => ({\n        seg,\n        hcoords: timelineCoords.rangeToCoords(seg),\n        top: topsByInstanceId[seg.eventRange.instance.instanceId],\n    }));\n}\nfunction buildAbsoluteTopHash(placements) {\n    let topsByInstanceId = {};\n    for (let placement of placements) {\n        let { seg } = placement;\n        if (!Array.isArray(seg)) { // doesn't represent a more-link\n            topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n        }\n    }\n    return topsByInstanceId;\n}\n\nclass TimelineGrid extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.slatsRef = createRef();\n        this.state = {\n            coords: null,\n        };\n        this.handeEl = (el) => {\n            if (el) {\n                this.context.registerInteractiveComponent(this, { el });\n            }\n            else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n        this.handleCoords = (coords) => {\n            this.setState({ coords });\n            if (this.props.onSlatCoords) {\n                this.props.onSlatCoords(coords);\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let { dateProfile, tDateProfile } = props;\n        let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n        return (createElement(\"div\", { className: \"fc-timeline-body\", ref: this.handeEl, style: {\n                minWidth: props.tableMinWidth,\n                height: props.clientHeight,\n                width: props.clientWidth,\n            } },\n            createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(Fragment, null,\n                createElement(TimelineSlats, { ref: this.slatsRef, dateProfile: dateProfile, tDateProfile: tDateProfile, nowDate: nowDate, todayRange: todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleCoords, onScrollLeftRequest: props.onScrollLeftRequest }),\n                createElement(TimelineLane, { dateProfile: dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, nextDayThreshold: options.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: state.coords, syncParentMinHeight: true }),\n                (options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate)) && (createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" },\n                    createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-line'], elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate }))))))));\n    }\n    // Hit System\n    // ------------------------------------------------------------------------------------------\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let slats = this.slatsRef.current;\n        let slatHit = slats.positionToHit(positionLeft);\n        if (slatHit) {\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: slatHit.dateSpan,\n                rect: {\n                    left: slatHit.left,\n                    right: slatHit.right,\n                    top: 0,\n                    bottom: elHeight,\n                },\n                dayEl: slatHit.dayEl,\n                layer: 0,\n            };\n        }\n        return null;\n    }\n}\n\nclass TimelineView extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n        this.scrollGridRef = createRef();\n        this.state = {\n            slatCoords: null,\n            slotCushionMaxWidth: null,\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n        };\n        this.handleScrollLeftRequest = (scrollLeft) => {\n            let scrollGrid = this.scrollGridRef.current;\n            scrollGrid.forceScrollLeft(0, scrollLeft);\n        };\n        this.handleMaxCushionWidth = (slotCushionMaxWidth) => {\n            this.setState({\n                slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth), // for less rerendering TODO: DRY\n            });\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n        let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n        let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n        let { slotMinWidth } = options;\n        let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n        let sections = [\n            {\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunks: [{\n                        key: 'timeline',\n                        content: (contentArg) => (createElement(TimelineHeader, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, slatCoords: state.slatCoords, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth })),\n                    }],\n            },\n            {\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunks: [{\n                        key: 'timeline',\n                        content: (contentArg) => (createElement(TimelineGrid, Object.assign({}, props, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, onSlatCoords: this.handleSlatCoords, onScrollLeftRequest: this.handleScrollLeftRequest }))),\n                    }],\n            },\n        ];\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: 'footer',\n                key: 'footer',\n                isSticky: true,\n                chunks: [{\n                        key: 'timeline',\n                        content: renderScrollShim,\n                    }],\n            });\n        }\n        return (createElement(ViewContainer, { elClasses: [\n                'fc-timeline',\n                options.eventOverlap === false ?\n                    'fc-timeline-overlap-disabled' :\n                    '',\n            ], viewSpec: context.viewSpec },\n            createElement(ScrollGrid, { ref: this.scrollGridRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [\n                    { cols: slatCols },\n                ], sections: sections })));\n    }\n    computeFallbackSlotMinWidth(tDateProfile) {\n        return Math.max(30, ((this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel));\n    }\n}\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n    return [{\n            span: tDateProfile.slotCnt,\n            minWidth: slotMinWidth || 1, // needs to be a non-zero number to trigger horizontal scrollbars!??????\n        }];\n}\n\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}