{"ast":null,"code":"import _slicedToArray from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _assertThisInitialized from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _toConsumableArray from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, BaseComponent, memoizeObjArg, memoize, getDateMeta, ContentContainer, getSlotClassNames, getDayClassNames, buildNavLinkAttrs, PositionCache, findDirectChildren, rangeContainsMarker, NowTimer, NowIndicatorContainer, findElements, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, Slicer, intersectRanges, addMs, StandardEvent, MoreLinkContainer, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewContainer, renderScrollShim, injectStyles } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment, createRef } from '@fullcalendar/core/preact.js';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid/internal.js';\nvar MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\nvar MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\nvar MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000;\n// potential nice values for slot-duration and interval-duration\nvar STOCK_SUB_DURATIONS = [{\n  years: 1\n}, {\n  months: 1\n}, {\n  days: 1\n}, {\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  minutes: 10\n}, {\n  minutes: 5\n}, {\n  minutes: 1\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}, {\n  seconds: 10\n}, {\n  seconds: 5\n}, {\n  seconds: 1\n}, {\n  milliseconds: 500\n}, {\n  milliseconds: 100\n}, {\n  milliseconds: 10\n}, {\n  milliseconds: 1\n}];\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n  var tDateProfile = {\n    labelInterval: allOptions.slotLabelInterval,\n    slotDuration: allOptions.slotDuration\n  };\n  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n  var input = allOptions.slotLabelFormat;\n  var rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n  tDateProfile.headerFormats = rawFormats.map(function (rawFormat) {\n    return createFormatter(rawFormat);\n  });\n  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n  var largeUnit = null;\n  if (!tDateProfile.isTimeScale) {\n    var slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n    if (/year|month|week/.test(slotUnit)) {\n      largeUnit = slotUnit;\n    }\n  }\n  tDateProfile.largeUnit = largeUnit;\n  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs('weeks', dateProfile, dateEnv) >= 2 && !allOptions.businessHours;\n  /*\n  console.log('label interval =', timelineView.labelInterval.humanize())\n  console.log('slot duration =', timelineView.slotDuration.humanize())\n  console.log('header formats =', timelineView.headerFormats)\n  console.log('isTimeScale', timelineView.isTimeScale)\n  console.log('largeUnit', timelineView.largeUnit)\n  */\n  var rawSnapDuration = allOptions.snapDuration;\n  var snapDuration;\n  var snapsPerSlot;\n  if (rawSnapDuration) {\n    snapDuration = createDuration(rawSnapDuration);\n    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);\n    // ^ TODO: warning if not whole?\n  }\n\n  if (snapsPerSlot == null) {\n    snapDuration = tDateProfile.slotDuration;\n    snapsPerSlot = 1;\n  }\n  tDateProfile.snapDuration = snapDuration;\n  tDateProfile.snapsPerSlot = snapsPerSlot;\n  // more...\n  var timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);\n  // TODO: why not use normalizeRange!?\n  var normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n  var normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);\n  // apply slotMinTime/slotMaxTime\n  // TODO: View should be responsible.\n  if (tDateProfile.isTimeScale) {\n    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n  }\n  tDateProfile.timeWindowMs = timeWindowMs;\n  tDateProfile.normalizedRange = {\n    start: normalizedStart,\n    end: normalizedEnd\n  };\n  var slotDates = [];\n  var date = normalizedStart;\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      slotDates.push(date);\n    }\n    date = dateEnv.add(date, tDateProfile.slotDuration);\n  }\n  tDateProfile.slotDates = slotDates;\n  // more...\n  var snapIndex = -1;\n  var snapDiff = 0; // index of the diff :(\n  var snapDiffToIndex = [];\n  var snapIndexToDiff = [];\n  date = normalizedStart;\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      snapIndex += 1;\n      snapDiffToIndex.push(snapIndex);\n      snapIndexToDiff.push(snapDiff);\n    } else {\n      snapDiffToIndex.push(snapIndex + 0.5);\n    }\n    date = dateEnv.add(date, tDateProfile.snapDuration);\n    snapDiff += 1;\n  }\n  tDateProfile.snapDiffToIndex = snapDiffToIndex;\n  tDateProfile.snapIndexToDiff = snapIndexToDiff;\n  tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;\n  // more...\n  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n  return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n  var normalDate = date;\n  if (!tDateProfile.isTimeScale) {\n    normalDate = startOfDay(normalDate);\n    if (tDateProfile.largeUnit) {\n      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n    }\n  }\n  return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n  if (!tDateProfile.isTimeScale) {\n    range = computeVisibleDayRange(range);\n    if (tDateProfile.largeUnit) {\n      var dayRange = range; // preserve original result\n      range = {\n        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)\n      };\n      // if date is partially through the interval, or is in the same interval as the start,\n      // make the exclusive end be the *next* interval\n      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n        range = {\n          start: range.start,\n          end: dateEnv.add(range.end, tDateProfile.slotDuration)\n        };\n      }\n    }\n  }\n  return range;\n}\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n  if (dateProfileGenerator.isHiddenDay(date)) {\n    return false;\n  }\n  if (tDateProfile.isTimeScale) {\n    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n    var day = startOfDay(date);\n    var timeMs = date.valueOf() - day.valueOf();\n    var ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n    ms = (ms % 86400000 + 86400000) % 86400000; // make negative values wrap to 24hr clock\n    return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n  }\n\n  return true;\n}\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  // make sure labelInterval doesn't exceed the max number of cells\n  if (tDateProfile.labelInterval) {\n    var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n    if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotLabelInterval results in too many cells');\n      tDateProfile.labelInterval = null;\n    }\n  }\n  // make sure slotDuration doesn't exceed the maximum number of cells\n  if (tDateProfile.slotDuration) {\n    var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n    if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotDuration results in too many cells');\n      tDateProfile.slotDuration = null;\n    }\n  }\n  // make sure labelInterval is a multiple of slotDuration\n  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n    var slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n    if (slotsPerLabel === null || slotsPerLabel < 1) {\n      console.warn('slotLabelInterval must be a multiple of slotDuration');\n      tDateProfile.slotDuration = null;\n    }\n  }\n}\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  var labelInterval = tDateProfile.labelInterval;\n  if (!labelInterval) {\n    // compute based off the slot duration\n    // find the largest label interval with an acceptable slots-per-label\n    var input;\n    if (tDateProfile.slotDuration) {\n      var _iterator = _createForOfIteratorHelper(STOCK_SUB_DURATIONS),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          input = _step.value;\n          var tryLabelInterval = createDuration(input);\n          var slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n          if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n            labelInterval = tryLabelInterval;\n            break;\n          }\n        }\n        // use the slot duration as a last resort\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (!labelInterval) {\n        labelInterval = tDateProfile.slotDuration;\n      }\n      // compute based off the view's duration\n      // find the largest label interval that yields the minimum number of labels\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(STOCK_SUB_DURATIONS),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          input = _step2.value;\n          labelInterval = createDuration(input);\n          var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n          if (labelCnt >= MIN_AUTO_LABELS) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    tDateProfile.labelInterval = labelInterval;\n  }\n  return labelInterval;\n}\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  var slotDuration = tDateProfile.slotDuration;\n  if (!slotDuration) {\n    var labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n    // compute based off the label interval\n    // find the largest slot duration that is different from labelInterval, but still acceptable\n    var _iterator3 = _createForOfIteratorHelper(STOCK_SUB_DURATIONS),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var input = _step3.value;\n        var trySlotDuration = createDuration(input);\n        var slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          slotDuration = trySlotDuration;\n          break;\n        }\n      }\n      // only allow the value if it won't exceed the view's # of slots limit\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    if (slotDuration) {\n      var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n      if (slotCnt > MAX_AUTO_CELLS) {\n        slotDuration = null;\n      }\n    }\n    // use the label interval as a last resort\n    if (!slotDuration) {\n      slotDuration = labelInterval;\n    }\n    tDateProfile.slotDuration = slotDuration;\n  }\n  return slotDuration;\n}\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n  var format1;\n  var format2;\n  var labelInterval = tDateProfile.labelInterval;\n  var unit = greatestDurationDenominator(labelInterval).unit;\n  var weekNumbersVisible = allOptions.weekNumbers;\n  var format0 = format1 = format2 = null;\n  // NOTE: weekNumber computation function wont work\n  if (unit === 'week' && !weekNumbersVisible) {\n    unit = 'day';\n  }\n  switch (unit) {\n    case 'year':\n      format0 = {\n        year: 'numeric'\n      }; // '2015'\n      break;\n    case 'month':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        month: 'short'\n      }; // 'Jan'\n      break;\n    case 'week':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        week: 'narrow'\n      }; // 'Wk4'\n      break;\n    case 'day':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric',\n          month: 'long'\n        }; // 'January 2014'\n      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n        format0 = {\n          month: 'long'\n        }; // 'January'\n      }\n\n      if (weekNumbersVisible) {\n        format1 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      format2 = {\n        weekday: 'narrow',\n        day: 'numeric'\n      }; // 'Su 9'\n      break;\n    case 'hour':\n      if (weekNumbersVisible) {\n        format0 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n        format1 = {\n          weekday: 'short',\n          day: 'numeric',\n          month: 'numeric',\n          omitCommas: true\n        }; // Sat 4/7\n      }\n\n      format2 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short'\n      };\n      break;\n    case 'minute':\n      // sufficiently large number of different minute cells?\n      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          meridiem: 'short'\n        };\n        format1 = function format1(params) {\n          return ':' + padStart(params.date.minute, 2) // ':30'\n          ;\n        };\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: 'numeric',\n          meridiem: 'short'\n        };\n      }\n      break;\n    case 'second':\n      // sufficiently large number of different second cells?\n      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30 PM'\n        format1 = function format1(params) {\n          return ':' + padStart(params.date.second, 2) // ':30'\n          ;\n        };\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          second: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30:45 PM'\n      }\n\n      break;\n    case 'millisecond':\n      format0 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        second: '2-digit',\n        meridiem: 'lowercase'\n      }; // '8:30:45 PM'\n      format1 = function format1(params) {\n        return '.' + padStart(params.millisecond, 3);\n      };\n      break;\n  }\n  return [].concat(format0 || [], format1 || [], format2 || []);\n}\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n  var range = dateProfile.currentRange;\n  var res = null;\n  if (unit === 'years') {\n    res = dateEnv.diffWholeYears(range.start, range.end);\n  } else if (unit === 'months') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'weeks') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'days') {\n    res = diffWholeDays(range.start, range.end);\n  }\n  return res || 0;\n}\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n  var slotDates = tDateProfile.slotDates,\n    emphasizeWeeks = tDateProfile.emphasizeWeeks;\n  var prevWeekNumber = null;\n  var isWeekStarts = [];\n  var _iterator4 = _createForOfIteratorHelper(slotDates),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var slotDate = _step4.value;\n      var weekNumber = dateEnv.computeWeekNumber(slotDate);\n      var isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;\n      prevWeekNumber = weekNumber;\n      isWeekStarts.push(isWeekStart);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return isWeekStarts;\n}\nfunction buildCellRows(tDateProfile, dateEnv) {\n  var slotDates = tDateProfile.slotDates;\n  var formats = tDateProfile.headerFormats;\n  var cellRows = formats.map(function () {\n    return [];\n  }); // indexed by row,col\n  var slotAsDays = asCleanDays(tDateProfile.slotDuration);\n  var guessedSlotUnit = slotAsDays === 7 ? 'week' : slotAsDays === 1 ? 'day' : null;\n  // specifically for navclicks\n  var rowUnitsFromFormats = formats.map(function (format) {\n    return format.getLargestUnit ? format.getLargestUnit() : null;\n  });\n  // builds cellRows and slotCells\n  for (var i = 0; i < slotDates.length; i += 1) {\n    var date = slotDates[i];\n    var isWeekStart = tDateProfile.isWeekStarts[i];\n    for (var row = 0; row < formats.length; row += 1) {\n      var format = formats[row];\n      var rowCells = cellRows[row];\n      var leadingCell = rowCells[rowCells.length - 1];\n      var isLastRow = row === formats.length - 1;\n      var isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n      var newCell = null;\n      var rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n      if (isSuperRow) {\n        var text = dateEnv.format(date, format);\n        if (!leadingCell || leadingCell.text !== text) {\n          newCell = buildCellObject(date, text, rowUnit);\n        } else {\n          leadingCell.colspan += 1;\n        }\n      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n        var _text = dateEnv.format(date, format);\n        newCell = buildCellObject(date, _text, rowUnit);\n      } else {\n        leadingCell.colspan += 1;\n      }\n      if (newCell) {\n        newCell.weekStart = isWeekStart;\n        rowCells.push(newCell);\n      }\n    }\n  }\n  return cellRows;\n}\nfunction buildCellObject(date, text, rowUnit) {\n  return {\n    date: date,\n    text: text,\n    rowUnit: rowUnit,\n    colspan: 1,\n    isWeekStart: false\n  };\n}\nvar TimelineHeaderTh = /*#__PURE__*/function (_BaseComponent) {\n  _inherits(TimelineHeaderTh, _BaseComponent);\n  var _super = _createSuper(TimelineHeaderTh);\n  function TimelineHeaderTh() {\n    var _this;\n    _classCallCheck(this, TimelineHeaderTh);\n    _this = _super.apply(this, arguments);\n    _this.refineRenderProps = memoizeObjArg(refineRenderProps);\n    _this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n    return _this;\n  }\n  _createClass(TimelineHeaderTh, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var props = this.props,\n        context = this.context;\n      var dateEnv = context.dateEnv,\n        options = context.options;\n      var cell = props.cell,\n        dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n      // the cell.rowUnit is f'd\n      // giving 'month' for a 3-day view\n      // workaround: to infer day, do NOT time\n      var dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n      var renderProps = this.refineRenderProps({\n        level: props.rowLevel,\n        dateMarker: cell.date,\n        text: cell.text,\n        dateEnv: context.dateEnv,\n        viewApi: context.viewApi\n      });\n      return createElement(ContentContainer, {\n        elTag: \"th\",\n        elClasses: ['fc-timeline-slot', 'fc-timeline-slot-label', cell.isWeekStart && 'fc-timeline-slot-em'].concat(_toConsumableArray(\n        // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n        cell.rowUnit === 'time' ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme))),\n        elAttrs: {\n          colSpan: cell.colspan,\n          'data-date': dateEnv.formatIso(cell.date, {\n            omitTime: !tDateProfile.isTimeScale,\n            omitTimeZoneOffset: true\n          })\n        },\n        renderProps: renderProps,\n        generatorName: \"slotLabelContent\",\n        customGenerator: options.slotLabelContent,\n        defaultGenerator: renderInnerContent,\n        classNameGenerator: options.slotLabelClassNames,\n        didMount: options.slotLabelDidMount,\n        willUnmount: options.slotLabelWillUnmount\n      }, function (InnerContent) {\n        return createElement(\"div\", {\n          className: \"fc-timeline-slot-frame\",\n          style: {\n            height: props.rowInnerHeight\n          }\n        }, createElement(InnerContent, {\n          elTag: \"a\",\n          elClasses: ['fc-timeline-slot-cushion', 'fc-scrollgrid-sync-inner', props.isSticky && 'fc-sticky'],\n          elAttrs: _this2.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)\n        }));\n      });\n    }\n  }]);\n  return TimelineHeaderTh;\n}(BaseComponent);\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n  return rowUnit && rowUnit !== 'time' ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};\n}\nfunction renderInnerContent(renderProps) {\n  return renderProps.text;\n}\nfunction refineRenderProps(input) {\n  return {\n    level: input.level,\n    date: input.dateEnv.toDate(input.dateMarker),\n    view: input.viewApi,\n    text: input.text\n  };\n}\nvar TimelineHeaderRows = /*#__PURE__*/function (_BaseComponent2) {\n  _inherits(TimelineHeaderRows, _BaseComponent2);\n  var _super2 = _createSuper(TimelineHeaderRows);\n  function TimelineHeaderRows() {\n    _classCallCheck(this, TimelineHeaderRows);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(TimelineHeaderRows, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        dateProfile = _this$props.dateProfile,\n        tDateProfile = _this$props.tDateProfile,\n        rowInnerHeights = _this$props.rowInnerHeights,\n        todayRange = _this$props.todayRange,\n        nowDate = _this$props.nowDate;\n      var cellRows = tDateProfile.cellRows;\n      return createElement(Fragment, null, cellRows.map(function (rowCells, rowLevel) {\n        var isLast = rowLevel === cellRows.length - 1;\n        var isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n        var classNames = ['fc-timeline-header-row', isChrono ? 'fc-timeline-header-row-chrono' : ''];\n        return (\n          // eslint-disable-next-line react/no-array-index-key\n          createElement(\"tr\", {\n            key: rowLevel,\n            className: classNames.join(' ')\n          }, rowCells.map(function (cell) {\n            return createElement(TimelineHeaderTh, {\n              key: cell.date.toISOString(),\n              cell: cell,\n              rowLevel: rowLevel,\n              dateProfile: dateProfile,\n              tDateProfile: tDateProfile,\n              todayRange: todayRange,\n              nowDate: nowDate,\n              rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel],\n              isSticky: !isLast\n            });\n          }))\n        );\n      }));\n    }\n  }]);\n  return TimelineHeaderRows;\n}(BaseComponent);\nvar TimelineCoords = /*#__PURE__*/function () {\n  function TimelineCoords(slatRootEl,\n  // okay to expose?\n  slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n    _classCallCheck(this, TimelineCoords);\n    this.slatRootEl = slatRootEl;\n    this.dateProfile = dateProfile;\n    this.tDateProfile = tDateProfile;\n    this.dateEnv = dateEnv;\n    this.isRtl = isRtl;\n    this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true,\n    // isHorizontal\n    false);\n    // for the inner divs within the slats\n    // used for event rendering and scrollTime, to disregard slat border\n    this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true,\n    // isHorizontal\n    false);\n  }\n  _createClass(TimelineCoords, [{\n    key: \"isDateInRange\",\n    value: function isDateInRange(date) {\n      return rangeContainsMarker(this.dateProfile.currentRange, date);\n    }\n    // results range from negative width of area to 0\n  }, {\n    key: \"dateToCoord\",\n    value: function dateToCoord(date) {\n      var tDateProfile = this.tDateProfile;\n      var snapCoverage = this.computeDateSnapCoverage(date);\n      var slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n      var slotIndex = Math.floor(slotCoverage);\n      slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n      var partial = slotCoverage - slotIndex;\n      var innerCoordCache = this.innerCoordCache,\n        outerCoordCache = this.outerCoordCache;\n      if (this.isRtl) {\n        return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);\n      }\n      return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;\n    }\n  }, {\n    key: \"rangeToCoords\",\n    value: function rangeToCoords(range) {\n      return {\n        start: this.dateToCoord(range.start),\n        end: this.dateToCoord(range.end)\n      };\n    }\n  }, {\n    key: \"durationToCoord\",\n    value: function durationToCoord(duration) {\n      var dateProfile = this.dateProfile,\n        tDateProfile = this.tDateProfile,\n        dateEnv = this.dateEnv,\n        isRtl = this.isRtl;\n      var coord = 0;\n      if (dateProfile) {\n        var date = dateEnv.add(dateProfile.activeRange.start, duration);\n        if (!tDateProfile.isTimeScale) {\n          date = startOfDay(date);\n        }\n        coord = this.dateToCoord(date);\n        // hack to overcome the left borders of non-first slat\n        if (!isRtl && coord) {\n          coord += 1;\n        }\n      }\n      return coord;\n    }\n  }, {\n    key: \"coordFromLeft\",\n    value: function coordFromLeft(coord) {\n      if (this.isRtl) {\n        return this.outerCoordCache.originClientRect.width - coord;\n      }\n      return coord;\n    }\n    // returned value is between 0 and the number of snaps\n  }, {\n    key: \"computeDateSnapCoverage\",\n    value: function computeDateSnapCoverage(date) {\n      return _computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n    }\n  }]);\n  return TimelineCoords;\n}(); // returned value is between 0 and the number of snaps\nfunction _computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n  var snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n  if (snapDiff < 0) {\n    return 0;\n  }\n  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n    return tDateProfile.snapCnt;\n  }\n  var snapDiffInt = Math.floor(snapDiff);\n  var snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n  if (isInt(snapCoverage)) {\n    // not an in-between value\n    snapCoverage += snapDiff - snapDiffInt; // add the remainder\n  } else {\n    // a fractional value, meaning the date is not visible\n    // always round up in this case. works for start AND end dates in a range.\n    snapCoverage = Math.ceil(snapCoverage);\n  }\n  return snapCoverage;\n}\nfunction coordToCss(hcoord, isRtl) {\n  if (hcoord === null) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n  if (isRtl) {\n    return {\n      right: hcoord,\n      left: ''\n    };\n  }\n  return {\n    left: hcoord,\n    right: ''\n  };\n}\nfunction coordsToCss(hcoords, isRtl) {\n  if (!hcoords) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n  if (isRtl) {\n    return {\n      right: hcoords.start,\n      left: -hcoords.end\n    };\n  }\n  return {\n    left: hcoords.start,\n    right: -hcoords.end\n  };\n}\nvar TimelineHeader = /*#__PURE__*/function (_BaseComponent3) {\n  _inherits(TimelineHeader, _BaseComponent3);\n  var _super3 = _createSuper(TimelineHeader);\n  function TimelineHeader() {\n    var _this3;\n    _classCallCheck(this, TimelineHeader);\n    _this3 = _super3.apply(this, arguments);\n    _this3.rootElRef = createRef();\n    return _this3;\n  }\n  _createClass(TimelineHeader, [{\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n      var props = this.props,\n        context = this.context;\n      // TODO: very repetitive\n      // TODO: make part of tDateProfile?\n      var timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;\n      // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n      var slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n      return createElement(NowTimer, {\n        unit: timerUnit\n      }, function (nowDate, todayRange) {\n        return createElement(\"div\", {\n          className: \"fc-timeline-header\",\n          ref: _this4.rootElRef\n        }, createElement(\"table\", {\n          \"aria-hidden\": true,\n          className: \"fc-scrollgrid-sync-table\",\n          style: {\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth\n          }\n        }, props.tableColGroupNode, createElement(\"tbody\", null, createElement(TimelineHeaderRows, {\n          dateProfile: props.dateProfile,\n          tDateProfile: props.tDateProfile,\n          nowDate: nowDate,\n          todayRange: todayRange,\n          rowInnerHeights: props.rowInnerHeights\n        }))), context.options.nowIndicator &&\n        // need to have a container regardless of whether the current view has a visible now indicator\n        // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n        // this issue doesn't happen for the timeline body however (\n        createElement(\"div\", {\n          className: \"fc-timeline-now-indicator-container\"\n        }, slatCoords && slatCoords.isDateInRange(nowDate) && createElement(NowIndicatorContainer, {\n          elClasses: ['fc-timeline-now-indicator-arrow'],\n          elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl),\n          isAxis: true,\n          date: nowDate\n        })));\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateSize();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateSize();\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize() {\n      if (this.props.onMaxCushionWidth) {\n        this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n      }\n    }\n  }, {\n    key: \"computeMaxCushionWidth\",\n    value: function computeMaxCushionWidth() {\n      return Math.max.apply(Math, _toConsumableArray(findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(function (el) {\n        return el.getBoundingClientRect().width;\n      })));\n    }\n  }]);\n  return TimelineHeader;\n}(BaseComponent);\nvar TimelineSlatCell = /*#__PURE__*/function (_BaseComponent4) {\n  _inherits(TimelineSlatCell, _BaseComponent4);\n  var _super4 = _createSuper(TimelineSlatCell);\n  function TimelineSlatCell() {\n    _classCallCheck(this, TimelineSlatCell);\n    return _super4.apply(this, arguments);\n  }\n  _createClass(TimelineSlatCell, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        context = this.context;\n      var dateEnv = context.dateEnv,\n        options = context.options,\n        theme = context.theme;\n      var date = props.date,\n        tDateProfile = props.tDateProfile,\n        isEm = props.isEm;\n      var dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n      var renderProps = Object.assign(Object.assign({\n        date: dateEnv.toDate(props.date)\n      }, dateMeta), {\n        view: context.viewApi\n      });\n      return createElement(ContentContainer, {\n        elTag: \"td\",\n        elRef: props.elRef,\n        elClasses: ['fc-timeline-slot', 'fc-timeline-slot-lane', isEm && 'fc-timeline-slot-em', tDateProfile.isTimeScale ? isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? 'fc-timeline-slot-major' : 'fc-timeline-slot-minor' : ''].concat(_toConsumableArray(props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme))),\n        elAttrs: {\n          'data-date': dateEnv.formatIso(date, {\n            omitTimeZoneOffset: true,\n            omitTime: !tDateProfile.isTimeScale\n          })\n        },\n        renderProps: renderProps,\n        generatorName: \"slotLaneContent\",\n        customGenerator: options.slotLaneContent,\n        classNameGenerator: options.slotLaneClassNames,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, function (InnerContent) {\n        return createElement(InnerContent, {\n          elTag: \"div\"\n        });\n      });\n    }\n  }]);\n  return TimelineSlatCell;\n}(BaseComponent);\nvar TimelineSlatsBody = /*#__PURE__*/function (_BaseComponent5) {\n  _inherits(TimelineSlatsBody, _BaseComponent5);\n  var _super5 = _createSuper(TimelineSlatsBody);\n  function TimelineSlatsBody() {\n    _classCallCheck(this, TimelineSlatsBody);\n    return _super5.apply(this, arguments);\n  }\n  _createClass(TimelineSlatsBody, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n      var tDateProfile = props.tDateProfile,\n        cellElRefs = props.cellElRefs;\n      var slotDates = tDateProfile.slotDates,\n        isWeekStarts = tDateProfile.isWeekStarts;\n      var isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n      return createElement(\"tbody\", null, createElement(\"tr\", null, slotDates.map(function (slotDate, i) {\n        var key = slotDate.toISOString();\n        return createElement(TimelineSlatCell, {\n          key: key,\n          elRef: cellElRefs.createRef(key),\n          date: slotDate,\n          dateProfile: props.dateProfile,\n          tDateProfile: tDateProfile,\n          nowDate: props.nowDate,\n          todayRange: props.todayRange,\n          isEm: isWeekStarts[i],\n          isDay: isDay\n        });\n      })));\n    }\n  }]);\n  return TimelineSlatsBody;\n}(BaseComponent);\nvar TimelineSlats = /*#__PURE__*/function (_BaseComponent6) {\n  _inherits(TimelineSlats, _BaseComponent6);\n  var _super6 = _createSuper(TimelineSlats);\n  function TimelineSlats() {\n    var _this5;\n    _classCallCheck(this, TimelineSlats);\n    _this5 = _super6.apply(this, arguments);\n    _this5.rootElRef = createRef();\n    _this5.cellElRefs = new RefMap();\n    _this5.handleScrollRequest = function (request) {\n      var onScrollLeftRequest = _this5.props.onScrollLeftRequest;\n      var _assertThisInitialize = _assertThisInitialized(_this5),\n        coords = _assertThisInitialize.coords;\n      if (onScrollLeftRequest && coords) {\n        if (request.time) {\n          var scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n          onScrollLeftRequest(scrollLeft);\n        }\n        return true;\n      }\n      return null; // best?\n    };\n    return _this5;\n  }\n  _createClass(TimelineSlats, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        context = this.context;\n      return createElement(\"div\", {\n        className: \"fc-timeline-slots\",\n        ref: this.rootElRef\n      }, createElement(\"table\", {\n        \"aria-hidden\": true,\n        className: context.theme.getClass('table'),\n        style: {\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth\n        }\n      }, props.tableColGroupNode, createElement(TimelineSlatsBody, {\n        cellElRefs: this.cellElRefs,\n        dateProfile: props.dateProfile,\n        tDateProfile: props.tDateProfile,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange\n      })));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateSizing();\n      this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.updateSizing();\n      this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.scrollResponder.detach();\n      if (this.props.onCoords) {\n        this.props.onCoords(null);\n      }\n    }\n  }, {\n    key: \"updateSizing\",\n    value: function updateSizing() {\n      var props = this.props,\n        context = this.context;\n      if (props.clientWidth !== null &&\n      // is sizing stable?\n      this.scrollResponder\n      // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n      ) {\n        var rootEl = this.rootElRef.current;\n        if (rootEl.offsetWidth) {\n          // not hidden by css\n          this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n          if (props.onCoords) {\n            props.onCoords(this.coords);\n          }\n          this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n        }\n      }\n    }\n  }, {\n    key: \"positionToHit\",\n    value: function positionToHit(leftPosition) {\n      var outerCoordCache = this.coords.outerCoordCache;\n      var _this$context = this.context,\n        dateEnv = _this$context.dateEnv,\n        isRtl = _this$context.isRtl;\n      var tDateProfile = this.props.tDateProfile;\n      var slatIndex = outerCoordCache.leftToIndex(leftPosition);\n      if (slatIndex != null) {\n        // somewhat similar to what TimeGrid does. consolidate?\n        var slatWidth = outerCoordCache.getWidth(slatIndex);\n        var partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n        var localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n        var start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n        var end = dateEnv.add(start, tDateProfile.snapDuration);\n        return {\n          dateSpan: {\n            range: {\n              start: start,\n              end: end\n            },\n            allDay: !this.props.tDateProfile.isTimeScale\n          },\n          dayEl: this.cellElRefs.currentMap[slatIndex],\n          left: outerCoordCache.lefts[slatIndex],\n          right: outerCoordCache.rights[slatIndex]\n        };\n      }\n      return null;\n    }\n  }]);\n  return TimelineSlats;\n}(BaseComponent);\nfunction collectCellEls(elMap, slotDates) {\n  return slotDates.map(function (slotDate) {\n    var key = slotDate.toISOString();\n    return elMap[key];\n  });\n}\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n  var hcoords = [];\n  if (timelineCoords) {\n    var _iterator5 = _createForOfIteratorHelper(segs),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var seg = _step5.value;\n        var res = timelineCoords.rangeToCoords(seg);\n        var start = Math.round(res.start); // for barely-overlapping collisions\n        var end = Math.round(res.end); //\n        if (end - start < minWidth) {\n          end = start + minWidth;\n        }\n        hcoords.push({\n          start: start,\n          end: end\n        });\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return hcoords;\n}\nfunction computeFgSegPlacements(segs, segHCoords,\n// might not have for every seg\neventInstanceHeights,\n// might not have for every seg\nmoreLinkHeights,\n// might not have for every more-link\nstrictOrder, maxStackCnt) {\n  var segInputs = [];\n  var crudePlacements = []; // when we don't know dims\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var height = eventInstanceHeights[instanceId];\n    var hcoords = segHCoords[i];\n    if (height && hcoords) {\n      segInputs.push({\n        index: i,\n        span: hcoords,\n        thickness: height\n      });\n    } else {\n      crudePlacements.push({\n        seg: seg,\n        hcoords: hcoords,\n        top: null\n      });\n    }\n  }\n  var hierarchy = new SegHierarchy();\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenPlacements = hiddenEntries.map(function (entry) {\n    return {\n      seg: segs[entry.index],\n      hcoords: entry.span,\n      top: null\n    };\n  });\n  var hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  var moreLinkInputs = [];\n  var moreLinkCrudePlacements = [];\n  var extractSeg = function extractSeg(entry) {\n    return segs[entry.index];\n  };\n  for (var _i = 0; _i < hiddenGroups.length; _i += 1) {\n    var hiddenGroup = hiddenGroups[_i];\n    var sortedSegs = hiddenGroup.entries.map(extractSeg);\n    var _height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n    if (_height != null) {\n      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n      moreLinkInputs.push({\n        index: segs.length + _i,\n        thickness: _height,\n        span: hiddenGroup.span\n      });\n    } else {\n      moreLinkCrudePlacements.push({\n        seg: sortedSegs,\n        hcoords: hiddenGroup.span,\n        top: null\n      });\n    }\n  }\n  // add more-links into the hierarchy, but don't limit\n  hierarchy.maxStackCnt = -1;\n  hierarchy.addSegs(moreLinkInputs);\n  var visibleRects = hierarchy.toRects();\n  var visiblePlacements = [];\n  var maxHeight = 0;\n  var _iterator6 = _createForOfIteratorHelper(visibleRects),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var rect = _step6.value;\n      var segIndex = rect.index;\n      visiblePlacements.push({\n        seg: segIndex < segs.length ? segs[segIndex] // a real seg\n        : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n        hcoords: rect.span,\n        top: rect.levelCoord\n      });\n      maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return [visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements), maxHeight];\n}\nvar TimelineLaneBg = /*#__PURE__*/function (_BaseComponent7) {\n  _inherits(TimelineLaneBg, _BaseComponent7);\n  var _super7 = _createSuper(TimelineLaneBg);\n  function TimelineLaneBg() {\n    _classCallCheck(this, TimelineLaneBg);\n    return _super7.apply(this, arguments);\n  }\n  _createClass(TimelineLaneBg, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n      var highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n      return props.timelineCoords && createElement(\"div\", {\n        className: \"fc-timeline-bg\"\n      }, this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'), this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'), this.renderSegs(highlightSeg, props.timelineCoords, 'highlight'));\n    }\n  }, {\n    key: \"renderSegs\",\n    value: function renderSegs(segs, timelineCoords, fillType) {\n      var _this$props2 = this.props,\n        todayRange = _this$props2.todayRange,\n        nowDate = _this$props2.nowDate;\n      var isRtl = this.context.isRtl;\n      var segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n      var children = segs.map(function (seg, i) {\n        var hcoords = segHCoords[i];\n        var hStyle = coordsToCss(hcoords, isRtl);\n        return createElement(\"div\", {\n          key: buildEventRangeKey(seg.eventRange),\n          className: \"fc-timeline-bg-harness\",\n          style: hStyle\n        }, fillType === 'bg-event' ? createElement(BgEvent, Object.assign({\n          seg: seg\n        }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));\n      });\n      return createElement(Fragment, null, children);\n    }\n  }]);\n  return TimelineLaneBg;\n}(BaseComponent);\nvar TimelineLaneSlicer = /*#__PURE__*/function (_Slicer) {\n  _inherits(TimelineLaneSlicer, _Slicer);\n  var _super8 = _createSuper(TimelineLaneSlicer);\n  function TimelineLaneSlicer() {\n    _classCallCheck(this, TimelineLaneSlicer);\n    return _super8.apply(this, arguments);\n  }\n  _createClass(TimelineLaneSlicer, [{\n    key: \"sliceRange\",\n    value: function sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n      var normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n      var segs = [];\n      // protect against when the span is entirely in an invalid date region\n      if (_computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < _computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n        // intersect the footprint's range with the grid's range\n        var slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n        if (slicedRange) {\n          segs.push({\n            start: slicedRange.start,\n            end: slicedRange.end,\n            isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n            isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)\n          });\n        }\n      }\n      return segs;\n    }\n  }]);\n  return TimelineLaneSlicer;\n}(Slicer);\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\nvar TimelineEvent = /*#__PURE__*/function (_BaseComponent8) {\n  _inherits(TimelineEvent, _BaseComponent8);\n  var _super9 = _createSuper(TimelineEvent);\n  function TimelineEvent() {\n    _classCallCheck(this, TimelineEvent);\n    return _super9.apply(this, arguments);\n  }\n  _createClass(TimelineEvent, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n      return createElement(StandardEvent, Object.assign({}, props, {\n        elClasses: ['fc-timeline-event', 'fc-h-event'],\n        defaultTimeFormat: DEFAULT_TIME_FORMAT,\n        defaultDisplayEventTime: !props.isTimeScale\n      }));\n    }\n  }]);\n  return TimelineEvent;\n}(BaseComponent);\nvar TimelineLaneMoreLink = /*#__PURE__*/function (_BaseComponent9) {\n  _inherits(TimelineLaneMoreLink, _BaseComponent9);\n  var _super10 = _createSuper(TimelineLaneMoreLink);\n  function TimelineLaneMoreLink() {\n    _classCallCheck(this, TimelineLaneMoreLink);\n    return _super10.apply(this, arguments);\n  }\n  _createClass(TimelineLaneMoreLink, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        context = this.context;\n      var hiddenSegs = props.hiddenSegs,\n        placement = props.placement,\n        resourceId = props.resourceId;\n      var top = placement.top,\n        hcoords = placement.hcoords;\n      var isVisible = hcoords && top !== null;\n      var hStyle = coordsToCss(hcoords, context.isRtl);\n      var extraDateSpan = resourceId ? {\n        resourceId: resourceId\n      } : {};\n      return createElement(MoreLinkContainer, {\n        elRef: props.elRef,\n        elClasses: ['fc-timeline-more-link'],\n        elStyle: Object.assign({\n          visibility: isVisible ? '' : 'hidden',\n          top: top || 0\n        }, hStyle),\n        allDayDate: null,\n        moreCnt: hiddenSegs.length,\n        allSegs: hiddenSegs,\n        hiddenSegs: hiddenSegs,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraDateSpan: extraDateSpan,\n        popoverContent: function popoverContent() {\n          return createElement(Fragment, null, hiddenSegs.map(function (seg) {\n            var instanceId = seg.eventRange.instance.instanceId;\n            return createElement(\"div\", {\n              key: instanceId,\n              style: {\n                visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ''\n              }\n            }, createElement(TimelineEvent, Object.assign({\n              isTimeScale: props.isTimeScale,\n              seg: seg,\n              isDragging: false,\n              isResizing: false,\n              isDateSelecting: false,\n              isSelected: instanceId === props.eventSelection\n            }, getSegMeta(seg, props.todayRange, props.nowDate))));\n          }));\n        }\n      }, function (InnerContent) {\n        return createElement(InnerContent, {\n          elTag: \"div\",\n          elClasses: ['fc-timeline-more-link-inner', 'fc-sticky']\n        });\n      });\n    }\n  }]);\n  return TimelineLaneMoreLink;\n}(BaseComponent);\nvar TimelineLane = /*#__PURE__*/function (_BaseComponent10) {\n  _inherits(TimelineLane, _BaseComponent10);\n  var _super11 = _createSuper(TimelineLane);\n  function TimelineLane() {\n    var _this6;\n    _classCallCheck(this, TimelineLane);\n    _this6 = _super11.apply(this, arguments);\n    _this6.slicer = new TimelineLaneSlicer();\n    _this6.sortEventSegs = memoize(sortEventSegs);\n    _this6.harnessElRefs = new RefMap();\n    _this6.moreElRefs = new RefMap();\n    _this6.innerElRef = createRef();\n    // TODO: memoize event positioning\n    _this6.state = {\n      eventInstanceHeights: {},\n      moreLinkHeights: {}\n    };\n    _this6.handleResize = function (isForced) {\n      if (isForced) {\n        _this6.updateSize();\n      }\n    };\n    return _this6;\n  }\n  _createClass(TimelineLane, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n        state = this.state,\n        context = this.context;\n      var options = context.options;\n      var dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n      var slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context,\n      // wish we didn't have to pass in the rest of the args...\n      dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n      var mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];\n      var fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n      var fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n      var _computeFgSegPlacemen = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack),\n        _computeFgSegPlacemen2 = _slicedToArray(_computeFgSegPlacemen, 2),\n        fgPlacements = _computeFgSegPlacemen2[0],\n        fgHeight = _computeFgSegPlacemen2[1];\n      var isForcedInvisible =\n      // TODO: more convenient\n      (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {};\n      return createElement(Fragment, null, createElement(TimelineLaneBg, {\n        businessHourSegs: slicedProps.businessHourSegs,\n        bgEventSegs: slicedProps.bgEventSegs,\n        timelineCoords: props.timelineCoords,\n        eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [] /* bad new empty array? */,\n        dateSelectionSegs: slicedProps.dateSelectionSegs,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange\n      }), createElement(\"div\", {\n        className: \"fc-timeline-events fc-scrollgrid-sync-inner\",\n        ref: this.innerElRef,\n        style: {\n          height: fgHeight\n        }\n      }, this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false), this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateSize();\n      this.context.addResizeHandler(this.handleResize);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (prevProps.eventStore !== this.props.eventStore ||\n      // external thing changed?\n      prevProps.timelineCoords !== this.props.timelineCoords ||\n      // external thing changed?\n      prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n      ) {\n        this.updateSize();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.context.removeResizeHandler(this.handleResize);\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize() {\n      var props = this.props;\n      var timelineCoords = props.timelineCoords;\n      var innerEl = this.innerElRef.current;\n      if (props.onHeightChange) {\n        props.onHeightChange(innerEl, false);\n      }\n      if (timelineCoords) {\n        this.setState({\n          eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, function (harnessEl) {\n            return Math.round(harnessEl.getBoundingClientRect().height);\n          }),\n          moreLinkHeights: mapHash(this.moreElRefs.currentMap, function (moreEl) {\n            return Math.round(moreEl.getBoundingClientRect().height);\n          })\n        }, function () {\n          if (props.onHeightChange) {\n            props.onHeightChange(innerEl, true);\n          }\n        });\n      }\n      // hack\n      if (props.syncParentMinHeight) {\n        innerEl.parentElement.style.minHeight = innerEl.style.height;\n      }\n    }\n  }, {\n    key: \"renderFgSegs\",\n    value: function renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n      var harnessElRefs = this.harnessElRefs,\n        moreElRefs = this.moreElRefs,\n        props = this.props,\n        context = this.context;\n      var isMirror = isDragging || isResizing || isDateSelecting;\n      return createElement(Fragment, null, segPlacements.map(function (segPlacement) {\n        var seg = segPlacement.seg,\n          hcoords = segPlacement.hcoords,\n          top = segPlacement.top;\n        if (Array.isArray(seg)) {\n          // a more-link\n          var isoStr = buildIsoString(computeEarliestSegStart(seg));\n          return createElement(TimelineLaneMoreLink, {\n            key: 'm:' + isoStr /* \"m\" for \"more\" */,\n            elRef: moreElRefs.createRef(isoStr),\n            hiddenSegs: seg,\n            placement: segPlacement,\n            dateProfile: props.dateProfile,\n            nowDate: props.nowDate,\n            todayRange: props.todayRange,\n            isTimeScale: props.tDateProfile.isTimeScale,\n            eventSelection: props.eventSelection,\n            resourceId: props.resourceId,\n            isForcedInvisible: isForcedInvisible\n          });\n        }\n        var instanceId = seg.eventRange.instance.instanceId;\n        var isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n        var hStyle = coordsToCss(hcoords, context.isRtl);\n        return createElement(\"div\", {\n          key: 'e:' + instanceId /* \"e\" for \"event\" */,\n          ref: isMirror ? null : harnessElRefs.createRef(instanceId),\n          className: \"fc-timeline-event-harness\",\n          style: Object.assign({\n            visibility: isVisible ? '' : 'hidden',\n            top: top || 0\n          }, hStyle)\n        }, createElement(TimelineEvent, Object.assign({\n          isTimeScale: props.tDateProfile.isTimeScale,\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === props.eventSelection /* TODO: bad for mirror? */\n        }, getSegMeta(seg, props.todayRange, props.nowDate))));\n      }));\n    }\n  }]);\n  return TimelineLane;\n}(BaseComponent);\nTimelineLane.addStateEquality({\n  eventInstanceHeights: isPropsEqual,\n  moreLinkHeights: isPropsEqual\n});\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n  if (!mirrorSegs.length || !timelineCoords) {\n    return [];\n  }\n  var topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      hcoords: timelineCoords.rangeToCoords(seg),\n      top: topsByInstanceId[seg.eventRange.instance.instanceId]\n    };\n  });\n}\nfunction buildAbsoluteTopHash(placements) {\n  var topsByInstanceId = {};\n  var _iterator7 = _createForOfIteratorHelper(placements),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var placement = _step7.value;\n      var seg = placement.seg;\n      if (!Array.isArray(seg)) {\n        // doesn't represent a more-link\n        topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return topsByInstanceId;\n}\nvar TimelineGrid = /*#__PURE__*/function (_DateComponent) {\n  _inherits(TimelineGrid, _DateComponent);\n  var _super12 = _createSuper(TimelineGrid);\n  function TimelineGrid() {\n    var _this7;\n    _classCallCheck(this, TimelineGrid);\n    _this7 = _super12.apply(this, arguments);\n    _this7.slatsRef = createRef();\n    _this7.state = {\n      coords: null\n    };\n    _this7.handeEl = function (el) {\n      if (el) {\n        _this7.context.registerInteractiveComponent(_assertThisInitialized(_this7), {\n          el: el\n        });\n      } else {\n        _this7.context.unregisterInteractiveComponent(_assertThisInitialized(_this7));\n      }\n    };\n    _this7.handleCoords = function (coords) {\n      _this7.setState({\n        coords: coords\n      });\n      if (_this7.props.onSlatCoords) {\n        _this7.props.onSlatCoords(coords);\n      }\n    };\n    return _this7;\n  }\n  _createClass(TimelineGrid, [{\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      var props = this.props,\n        state = this.state,\n        context = this.context;\n      var options = context.options;\n      var dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n      var timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n      return createElement(\"div\", {\n        className: \"fc-timeline-body\",\n        ref: this.handeEl,\n        style: {\n          minWidth: props.tableMinWidth,\n          height: props.clientHeight,\n          width: props.clientWidth\n        }\n      }, createElement(NowTimer, {\n        unit: timerUnit\n      }, function (nowDate, todayRange) {\n        return createElement(Fragment, null, createElement(TimelineSlats, {\n          ref: _this8.slatsRef,\n          dateProfile: dateProfile,\n          tDateProfile: tDateProfile,\n          nowDate: nowDate,\n          todayRange: todayRange,\n          clientWidth: props.clientWidth,\n          tableColGroupNode: props.tableColGroupNode,\n          tableMinWidth: props.tableMinWidth,\n          onCoords: _this8.handleCoords,\n          onScrollLeftRequest: props.onScrollLeftRequest\n        }), createElement(TimelineLane, {\n          dateProfile: dateProfile,\n          tDateProfile: props.tDateProfile,\n          nowDate: nowDate,\n          todayRange: todayRange,\n          nextDayThreshold: options.nextDayThreshold,\n          businessHours: props.businessHours,\n          eventStore: props.eventStore,\n          eventUiBases: props.eventUiBases,\n          dateSelection: props.dateSelection,\n          eventSelection: props.eventSelection,\n          eventDrag: props.eventDrag,\n          eventResize: props.eventResize,\n          timelineCoords: state.coords,\n          syncParentMinHeight: true\n        }), options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && createElement(\"div\", {\n          className: \"fc-timeline-now-indicator-container\"\n        }, createElement(NowIndicatorContainer, {\n          elClasses: ['fc-timeline-now-indicator-line'],\n          elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl),\n          isAxis: false,\n          date: nowDate\n        })));\n      }));\n    }\n    // Hit System\n    // ------------------------------------------------------------------------------------------\n  }, {\n    key: \"queryHit\",\n    value: function queryHit(positionLeft, positionTop, elWidth, elHeight) {\n      var slats = this.slatsRef.current;\n      var slatHit = slats.positionToHit(positionLeft);\n      if (slatHit) {\n        return {\n          dateProfile: this.props.dateProfile,\n          dateSpan: slatHit.dateSpan,\n          rect: {\n            left: slatHit.left,\n            right: slatHit.right,\n            top: 0,\n            bottom: elHeight\n          },\n          dayEl: slatHit.dayEl,\n          layer: 0\n        };\n      }\n      return null;\n    }\n  }]);\n  return TimelineGrid;\n}(DateComponent);\nvar TimelineView = /*#__PURE__*/function (_DateComponent2) {\n  _inherits(TimelineView, _DateComponent2);\n  var _super13 = _createSuper(TimelineView);\n  function TimelineView() {\n    var _this9;\n    _classCallCheck(this, TimelineView);\n    _this9 = _super13.apply(this, arguments);\n    _this9.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n    _this9.scrollGridRef = createRef();\n    _this9.state = {\n      slatCoords: null,\n      slotCushionMaxWidth: null\n    };\n    _this9.handleSlatCoords = function (slatCoords) {\n      _this9.setState({\n        slatCoords: slatCoords\n      });\n    };\n    _this9.handleScrollLeftRequest = function (scrollLeft) {\n      var scrollGrid = _this9.scrollGridRef.current;\n      scrollGrid.forceScrollLeft(0, scrollLeft);\n    };\n    _this9.handleMaxCushionWidth = function (slotCushionMaxWidth) {\n      _this9.setState({\n        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth) // for less rerendering TODO: DRY\n      });\n    };\n    return _this9;\n  }\n  _createClass(TimelineView, [{\n    key: \"render\",\n    value: function render() {\n      var _this10 = this;\n      var props = this.props,\n        state = this.state,\n        context = this.context;\n      var options = context.options;\n      var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n      var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n      var tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n      var slotMinWidth = options.slotMinWidth;\n      var slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n      var sections = [{\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'timeline',\n          content: function content(contentArg) {\n            return createElement(TimelineHeader, {\n              dateProfile: props.dateProfile,\n              clientWidth: contentArg.clientWidth,\n              clientHeight: contentArg.clientHeight,\n              tableMinWidth: contentArg.tableMinWidth,\n              tableColGroupNode: contentArg.tableColGroupNode,\n              tDateProfile: tDateProfile,\n              slatCoords: state.slatCoords,\n              onMaxCushionWidth: slotMinWidth ? null : _this10.handleMaxCushionWidth\n            });\n          }\n        }]\n      }, {\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        chunks: [{\n          key: 'timeline',\n          content: function content(contentArg) {\n            return createElement(TimelineGrid, Object.assign({}, props, {\n              clientWidth: contentArg.clientWidth,\n              clientHeight: contentArg.clientHeight,\n              tableMinWidth: contentArg.tableMinWidth,\n              tableColGroupNode: contentArg.tableColGroupNode,\n              tDateProfile: tDateProfile,\n              onSlatCoords: _this10.handleSlatCoords,\n              onScrollLeftRequest: _this10.handleScrollLeftRequest\n            }));\n          }\n        }]\n      }];\n      if (stickyFooterScrollbar) {\n        sections.push({\n          type: 'footer',\n          key: 'footer',\n          isSticky: true,\n          chunks: [{\n            key: 'timeline',\n            content: renderScrollShim\n          }]\n        });\n      }\n      return createElement(ViewContainer, {\n        elClasses: ['fc-timeline', options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : ''],\n        viewSpec: context.viewSpec\n      }, createElement(ScrollGrid, {\n        ref: this.scrollGridRef,\n        liquid: !props.isHeightAuto && !props.forPrint,\n        forPrint: props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          cols: slatCols\n        }],\n        sections: sections\n      }));\n    }\n  }, {\n    key: \"computeFallbackSlotMinWidth\",\n    value: function computeFallbackSlotMinWidth(tDateProfile) {\n      return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);\n    }\n  }]);\n  return TimelineView;\n}(DateComponent);\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n  return [{\n    span: tDateProfile.slotCnt,\n    minWidth: slotMinWidth || 1 // needs to be a non-zero number to trigger horizontal scrollbars!??????\n  }];\n}\n\nvar css_248z = \".fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;pointer-events:none;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:\\\"\\\";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}\";\ninjectStyles(css_248z);\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };","map":{"version":3,"names":["config","createFormatter","greatestDurationDenominator","asCleanDays","createDuration","wholeDivideDurations","asRoughMs","addDays","startOfDay","asRoughSeconds","asRoughMinutes","diffWholeDays","isInt","computeVisibleDayRange","padStart","BaseComponent","memoizeObjArg","memoize","getDateMeta","ContentContainer","getSlotClassNames","getDayClassNames","buildNavLinkAttrs","PositionCache","findDirectChildren","rangeContainsMarker","NowTimer","NowIndicatorContainer","findElements","RefMap","multiplyDuration","SegHierarchy","groupIntersectingEntries","buildIsoString","computeEarliestSegStart","buildEventRangeKey","BgEvent","getSegMeta","renderFill","Slicer","intersectRanges","addMs","StandardEvent","MoreLinkContainer","sortEventSegs","mapHash","isPropsEqual","DateComponent","getStickyHeaderDates","getStickyFooterScrollbar","ViewContainer","renderScrollShim","injectStyles","createElement","Fragment","createRef","ScrollGrid","MIN_AUTO_LABELS","MAX_AUTO_SLOTS_PER_LABEL","MAX_AUTO_CELLS","MAX_TIMELINE_SLOTS","STOCK_SUB_DURATIONS","years","months","days","hours","minutes","seconds","milliseconds","buildTimelineDateProfile","dateProfile","dateEnv","allOptions","dateProfileGenerator","tDateProfile","labelInterval","slotLabelInterval","slotDuration","validateLabelAndSlot","ensureLabelInterval","ensureSlotDuration","input","slotLabelFormat","rawFormats","Array","isArray","computeHeaderFormats","headerFormats","map","rawFormat","isTimeScale","Boolean","largeUnit","slotUnit","unit","test","emphasizeWeeks","currentRangeAs","businessHours","rawSnapDuration","snapDuration","snapsPerSlot","timeWindowMs","slotMaxTime","slotMinTime","normalizedStart","normalizeDate","renderRange","start","normalizedEnd","end","add","normalizedRange","slotDates","date","isValidDate","push","snapIndex","snapDiff","snapDiffToIndex","snapIndexToDiff","snapCnt","slotCnt","isWeekStarts","buildIsWeekStarts","cellRows","buildCellRows","slotsPerLabel","normalDate","startOf","normalizeRange","range","dayRange","valueOf","isHiddenDay","day","timeMs","ms","currentRange","labelCnt","countDurationsBetween","console","warn","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","tryLabelInterval","err","e","f","_iterator2","_step2","_iterator3","_step3","trySlotDuration","format1","format2","weekNumbersVisible","weekNumbers","format0","year","month","week","weekday","omitCommas","hour","minute","omitZeroMinute","meridiem","params","second","millisecond","concat","res","diffWholeYears","diffWholeMonths","prevWeekNumber","_iterator4","_step4","slotDate","weekNumber","computeWeekNumber","isWeekStart","formats","slotAsDays","guessedSlotUnit","rowUnitsFromFormats","format","getLargestUnit","i","length","row","rowCells","leadingCell","isLastRow","isSuperRow","newCell","rowUnit","text","buildCellObject","colspan","weekStart","TimelineHeaderTh","_BaseComponent","_inherits","_super","_createSuper","_this","_classCallCheck","apply","arguments","refineRenderProps","buildCellNavLinkAttrs","_createClass","key","render","_this2","props","context","options","cell","dateMeta","todayRange","nowDate","renderProps","level","rowLevel","dateMarker","viewApi","elTag","elClasses","_toConsumableArray","theme","elAttrs","colSpan","formatIso","omitTime","omitTimeZoneOffset","generatorName","customGenerator","slotLabelContent","defaultGenerator","renderInnerContent","classNameGenerator","slotLabelClassNames","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","InnerContent","className","style","height","rowInnerHeight","isSticky","cellDate","toDate","view","TimelineHeaderRows","_BaseComponent2","_super2","_this$props","rowInnerHeights","isLast","isChrono","classNames","join","toISOString","TimelineCoords","slatRootEl","slatEls","isRtl","outerCoordCache","innerCoordCache","isDateInRange","dateToCoord","snapCoverage","computeDateSnapCoverage","slotCoverage","slotIndex","Math","floor","min","partial","originClientRect","width","rights","getWidth","lefts","rangeToCoords","durationToCoord","duration","coord","activeRange","coordFromLeft","snapDiffInt","ceil","coordToCss","hcoord","left","right","coordsToCss","hcoords","TimelineHeader","_BaseComponent3","_super3","_this3","rootElRef","_this4","timerUnit","slatCoords","ref","minWidth","tableMinWidth","clientWidth","tableColGroupNode","nowIndicator","elStyle","isAxis","componentDidMount","updateSize","componentDidUpdate","onMaxCushionWidth","computeMaxCushionWidth","max","current","el","getBoundingClientRect","TimelineSlatCell","_BaseComponent4","_super4","isEm","Object","assign","elRef","isDay","slotLaneContent","slotLaneClassNames","slotLaneDidMount","slotLaneWillUnmount","TimelineSlatsBody","_BaseComponent5","_super5","cellElRefs","TimelineSlats","_BaseComponent6","_super6","_this5","handleScrollRequest","request","onScrollLeftRequest","_assertThisInitialize","_assertThisInitialized","coords","time","scrollLeft","getClass","updateSizing","scrollResponder","createScrollResponder","prevProps","update","componentWillUnmount","detach","onCoords","rootEl","offsetWidth","collectCellEls","currentMap","positionToHit","leftPosition","_this$context","slatIndex","leftToIndex","slatWidth","localSnapIndex","dateSpan","allDay","dayEl","elMap","computeSegHCoords","segs","timelineCoords","_iterator5","_step5","seg","round","computeFgSegPlacements","segHCoords","eventInstanceHeights","moreLinkHeights","strictOrder","maxStackCnt","segInputs","crudePlacements","instanceId","eventRange","instance","index","span","thickness","top","hierarchy","hiddenEntries","addSegs","hiddenPlacements","entry","hiddenGroups","moreLinkInputs","moreLinkCrudePlacements","extractSeg","hiddenGroup","sortedSegs","entries","visibleRects","toRects","visiblePlacements","maxHeight","_iterator6","_step6","rect","segIndex","levelCoord","TimelineLaneBg","_BaseComponent7","_super7","highlightSeg","eventResizeSegs","dateSelectionSegs","renderSegs","businessHourSegs","bgEventSegs","fillType","_this$props2","children","hStyle","TimelineLaneSlicer","_Slicer","_super8","sliceRange","origRange","normalRange","slicedRange","isStart","isEnd","DEFAULT_TIME_FORMAT","TimelineEvent","_BaseComponent8","_super9","defaultTimeFormat","defaultDisplayEventTime","TimelineLaneMoreLink","_BaseComponent9","_super10","hiddenSegs","placement","resourceId","isVisible","extraDateSpan","visibility","allDayDate","moreCnt","allSegs","popoverContent","isForcedInvisible","isDragging","isResizing","isDateSelecting","isSelected","eventSelection","TimelineLane","_BaseComponent10","_super11","_this6","slicer","harnessElRefs","moreElRefs","innerElRef","state","handleResize","isForced","slicedProps","sliceProps","nextDayThreshold","mirrorSegs","eventDrag","eventResize","fgSegs","fgEventSegs","eventOrder","fgSegHCoords","eventMinWidth","_computeFgSegPlacemen","eventOrderStrict","eventMaxStack","_computeFgSegPlacemen2","_slicedToArray","fgPlacements","fgHeight","affectedInstances","renderFgSegs","buildMirrorPlacements","addResizeHandler","prevState","eventStore","removeResizeHandler","innerEl","onHeightChange","setState","harnessEl","moreEl","syncParentMinHeight","parentElement","minHeight","segPlacements","isMirror","segPlacement","isoStr","addStateEquality","topsByInstanceId","buildAbsoluteTopHash","placements","_iterator7","_step7","TimelineGrid","_DateComponent","_super12","_this7","slatsRef","handeEl","registerInteractiveComponent","unregisterInteractiveComponent","handleCoords","onSlatCoords","_this8","clientHeight","eventUiBases","dateSelection","queryHit","positionLeft","positionTop","elWidth","elHeight","slats","slatHit","bottom","layer","TimelineView","_DateComponent2","_super13","_this9","scrollGridRef","slotCushionMaxWidth","handleSlatCoords","handleScrollLeftRequest","scrollGrid","forceScrollLeft","handleMaxCushionWidth","_this10","stickyHeaderDates","forPrint","stickyFooterScrollbar","slotMinWidth","slatCols","buildSlatCols","computeFallbackSlotMinWidth","sections","type","chunks","content","contentArg","liquid","eventOverlap","viewSpec","isHeightAuto","collapsibleWidth","colGroups","cols","css_248z"],"sources":["C:/Users/erden/OneDrive/Documents/GitHub/techclubsite/streamlit_calendar/frontend/node_modules/@fullcalendar/timeline/internal.js"],"sourcesContent":["import { config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, BaseComponent, memoizeObjArg, memoize, getDateMeta, ContentContainer, getSlotClassNames, getDayClassNames, buildNavLinkAttrs, PositionCache, findDirectChildren, rangeContainsMarker, NowTimer, NowIndicatorContainer, findElements, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, Slicer, intersectRanges, addMs, StandardEvent, MoreLinkContainer, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewContainer, renderScrollShim, injectStyles } from '@fullcalendar/core/internal.js';\nimport { createElement, Fragment, createRef } from '@fullcalendar/core/preact.js';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid/internal.js';\n\nconst MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\nconst MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\nconst MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000;\n// potential nice values for slot-duration and interval-duration\nconst STOCK_SUB_DURATIONS = [\n    { years: 1 },\n    { months: 1 },\n    { days: 1 },\n    { hours: 1 },\n    { minutes: 30 },\n    { minutes: 15 },\n    { minutes: 10 },\n    { minutes: 5 },\n    { minutes: 1 },\n    { seconds: 30 },\n    { seconds: 15 },\n    { seconds: 10 },\n    { seconds: 5 },\n    { seconds: 1 },\n    { milliseconds: 500 },\n    { milliseconds: 100 },\n    { milliseconds: 10 },\n    { milliseconds: 1 },\n];\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n    let tDateProfile = {\n        labelInterval: allOptions.slotLabelInterval,\n        slotDuration: allOptions.slotDuration,\n    };\n    validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n    ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n    ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n    let input = allOptions.slotLabelFormat;\n    let rawFormats = Array.isArray(input) ? input :\n        (input != null) ? [input] :\n            computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n    tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat));\n    tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n    let largeUnit = null;\n    if (!tDateProfile.isTimeScale) {\n        const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n        if (/year|month|week/.test(slotUnit)) {\n            largeUnit = slotUnit;\n        }\n    }\n    tDateProfile.largeUnit = largeUnit;\n    tDateProfile.emphasizeWeeks =\n        asCleanDays(tDateProfile.slotDuration) === 1 &&\n            currentRangeAs('weeks', dateProfile, dateEnv) >= 2 &&\n            !allOptions.businessHours;\n    /*\n    console.log('label interval =', timelineView.labelInterval.humanize())\n    console.log('slot duration =', timelineView.slotDuration.humanize())\n    console.log('header formats =', timelineView.headerFormats)\n    console.log('isTimeScale', timelineView.isTimeScale)\n    console.log('largeUnit', timelineView.largeUnit)\n    */\n    let rawSnapDuration = allOptions.snapDuration;\n    let snapDuration;\n    let snapsPerSlot;\n    if (rawSnapDuration) {\n        snapDuration = createDuration(rawSnapDuration);\n        snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);\n        // ^ TODO: warning if not whole?\n    }\n    if (snapsPerSlot == null) {\n        snapDuration = tDateProfile.slotDuration;\n        snapsPerSlot = 1;\n    }\n    tDateProfile.snapDuration = snapDuration;\n    tDateProfile.snapsPerSlot = snapsPerSlot;\n    // more...\n    let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);\n    // TODO: why not use normalizeRange!?\n    let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n    let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);\n    // apply slotMinTime/slotMaxTime\n    // TODO: View should be responsible.\n    if (tDateProfile.isTimeScale) {\n        normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n        normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n    }\n    tDateProfile.timeWindowMs = timeWindowMs;\n    tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd };\n    let slotDates = [];\n    let date = normalizedStart;\n    while (date < normalizedEnd) {\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n            slotDates.push(date);\n        }\n        date = dateEnv.add(date, tDateProfile.slotDuration);\n    }\n    tDateProfile.slotDates = slotDates;\n    // more...\n    let snapIndex = -1;\n    let snapDiff = 0; // index of the diff :(\n    const snapDiffToIndex = [];\n    const snapIndexToDiff = [];\n    date = normalizedStart;\n    while (date < normalizedEnd) {\n        if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n            snapIndex += 1;\n            snapDiffToIndex.push(snapIndex);\n            snapIndexToDiff.push(snapDiff);\n        }\n        else {\n            snapDiffToIndex.push(snapIndex + 0.5);\n        }\n        date = dateEnv.add(date, tDateProfile.snapDuration);\n        snapDiff += 1;\n    }\n    tDateProfile.snapDiffToIndex = snapDiffToIndex;\n    tDateProfile.snapIndexToDiff = snapIndexToDiff;\n    tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n    tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;\n    // more...\n    tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n    tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n    tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n    return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n    let normalDate = date;\n    if (!tDateProfile.isTimeScale) {\n        normalDate = startOfDay(normalDate);\n        if (tDateProfile.largeUnit) {\n            normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n        }\n    }\n    return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n    if (!tDateProfile.isTimeScale) {\n        range = computeVisibleDayRange(range);\n        if (tDateProfile.largeUnit) {\n            let dayRange = range; // preserve original result\n            range = {\n                start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n                end: dateEnv.startOf(range.end, tDateProfile.largeUnit),\n            };\n            // if date is partially through the interval, or is in the same interval as the start,\n            // make the exclusive end be the *next* interval\n            if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n                range = {\n                    start: range.start,\n                    end: dateEnv.add(range.end, tDateProfile.slotDuration),\n                };\n            }\n        }\n    }\n    return range;\n}\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n    if (dateProfileGenerator.isHiddenDay(date)) {\n        return false;\n    }\n    if (tDateProfile.isTimeScale) {\n        // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n        let day = startOfDay(date);\n        let timeMs = date.valueOf() - day.valueOf();\n        let ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n        ms = ((ms % 86400000) + 86400000) % 86400000; // make negative values wrap to 24hr clock\n        return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n    }\n    return true;\n}\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    // make sure labelInterval doesn't exceed the max number of cells\n    if (tDateProfile.labelInterval) {\n        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n        if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n            console.warn('slotLabelInterval results in too many cells');\n            tDateProfile.labelInterval = null;\n        }\n    }\n    // make sure slotDuration doesn't exceed the maximum number of cells\n    if (tDateProfile.slotDuration) {\n        const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n        if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n            console.warn('slotDuration results in too many cells');\n            tDateProfile.slotDuration = null;\n        }\n    }\n    // make sure labelInterval is a multiple of slotDuration\n    if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n        const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n        if (slotsPerLabel === null || slotsPerLabel < 1) {\n            console.warn('slotLabelInterval must be a multiple of slotDuration');\n            tDateProfile.slotDuration = null;\n        }\n    }\n}\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    let { labelInterval } = tDateProfile;\n    if (!labelInterval) {\n        // compute based off the slot duration\n        // find the largest label interval with an acceptable slots-per-label\n        let input;\n        if (tDateProfile.slotDuration) {\n            for (input of STOCK_SUB_DURATIONS) {\n                const tryLabelInterval = createDuration(input);\n                const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n                if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n                    labelInterval = tryLabelInterval;\n                    break;\n                }\n            }\n            // use the slot duration as a last resort\n            if (!labelInterval) {\n                labelInterval = tDateProfile.slotDuration;\n            }\n            // compute based off the view's duration\n            // find the largest label interval that yields the minimum number of labels\n        }\n        else {\n            for (input of STOCK_SUB_DURATIONS) {\n                labelInterval = createDuration(input);\n                const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n                if (labelCnt >= MIN_AUTO_LABELS) {\n                    break;\n                }\n            }\n        }\n        tDateProfile.labelInterval = labelInterval;\n    }\n    return labelInterval;\n}\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n    const { currentRange } = dateProfile;\n    let { slotDuration } = tDateProfile;\n    if (!slotDuration) {\n        const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n        // compute based off the label interval\n        // find the largest slot duration that is different from labelInterval, but still acceptable\n        for (let input of STOCK_SUB_DURATIONS) {\n            const trySlotDuration = createDuration(input);\n            const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n            if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n                slotDuration = trySlotDuration;\n                break;\n            }\n        }\n        // only allow the value if it won't exceed the view's # of slots limit\n        if (slotDuration) {\n            const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n            if (slotCnt > MAX_AUTO_CELLS) {\n                slotDuration = null;\n            }\n        }\n        // use the label interval as a last resort\n        if (!slotDuration) {\n            slotDuration = labelInterval;\n        }\n        tDateProfile.slotDuration = slotDuration;\n    }\n    return slotDuration;\n}\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n    let format1;\n    let format2;\n    const { labelInterval } = tDateProfile;\n    let unit = greatestDurationDenominator(labelInterval).unit;\n    const weekNumbersVisible = allOptions.weekNumbers;\n    let format0 = (format1 = (format2 = null));\n    // NOTE: weekNumber computation function wont work\n    if ((unit === 'week') && !weekNumbersVisible) {\n        unit = 'day';\n    }\n    switch (unit) {\n        case 'year':\n            format0 = { year: 'numeric' }; // '2015'\n            break;\n        case 'month':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric' }; // '2015'\n            }\n            format1 = { month: 'short' }; // 'Jan'\n            break;\n        case 'week':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric' }; // '2015'\n            }\n            format1 = { week: 'narrow' }; // 'Wk4'\n            break;\n        case 'day':\n            if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n                format0 = { year: 'numeric', month: 'long' }; // 'January 2014'\n            }\n            else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n                format0 = { month: 'long' }; // 'January'\n            }\n            if (weekNumbersVisible) {\n                format1 = { week: 'short' }; // 'Wk 4'\n            }\n            format2 = { weekday: 'narrow', day: 'numeric' }; // 'Su 9'\n            break;\n        case 'hour':\n            if (weekNumbersVisible) {\n                format0 = { week: 'short' }; // 'Wk 4'\n            }\n            if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n                format1 = { weekday: 'short', day: 'numeric', month: 'numeric', omitCommas: true }; // Sat 4/7\n            }\n            format2 = {\n                hour: 'numeric',\n                minute: '2-digit',\n                omitZeroMinute: true,\n                meridiem: 'short',\n            };\n            break;\n        case 'minute':\n            // sufficiently large number of different minute cells?\n            if ((asRoughMinutes(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                format0 = {\n                    hour: 'numeric',\n                    meridiem: 'short',\n                };\n                format1 = (params) => (':' + padStart(params.date.minute, 2) // ':30'\n                );\n            }\n            else {\n                format0 = {\n                    hour: 'numeric',\n                    minute: 'numeric',\n                    meridiem: 'short',\n                };\n            }\n            break;\n        case 'second':\n            // sufficiently large number of different second cells?\n            if ((asRoughSeconds(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n                format0 = { hour: 'numeric', minute: '2-digit', meridiem: 'lowercase' }; // '8:30 PM'\n                format1 = (params) => (':' + padStart(params.date.second, 2) // ':30'\n                );\n            }\n            else {\n                format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\n            }\n            break;\n        case 'millisecond':\n            format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' }; // '8:30:45 PM'\n            format1 = (params) => ('.' + padStart(params.millisecond, 3));\n            break;\n    }\n    return [].concat(format0 || [], format1 || [], format2 || []);\n}\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n    let range = dateProfile.currentRange;\n    let res = null;\n    if (unit === 'years') {\n        res = dateEnv.diffWholeYears(range.start, range.end);\n    }\n    else if (unit === 'months') {\n        res = dateEnv.diffWholeMonths(range.start, range.end);\n    }\n    else if (unit === 'weeks') {\n        res = dateEnv.diffWholeMonths(range.start, range.end);\n    }\n    else if (unit === 'days') {\n        res = diffWholeDays(range.start, range.end);\n    }\n    return res || 0;\n}\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n    let { slotDates, emphasizeWeeks } = tDateProfile;\n    let prevWeekNumber = null;\n    let isWeekStarts = [];\n    for (let slotDate of slotDates) {\n        let weekNumber = dateEnv.computeWeekNumber(slotDate);\n        let isWeekStart = emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber);\n        prevWeekNumber = weekNumber;\n        isWeekStarts.push(isWeekStart);\n    }\n    return isWeekStarts;\n}\nfunction buildCellRows(tDateProfile, dateEnv) {\n    let slotDates = tDateProfile.slotDates;\n    let formats = tDateProfile.headerFormats;\n    let cellRows = formats.map(() => []); // indexed by row,col\n    let slotAsDays = asCleanDays(tDateProfile.slotDuration);\n    let guessedSlotUnit = slotAsDays === 7 ? 'week' :\n        slotAsDays === 1 ? 'day' :\n            null;\n    // specifically for navclicks\n    let rowUnitsFromFormats = formats.map((format) => (format.getLargestUnit ? format.getLargestUnit() : null));\n    // builds cellRows and slotCells\n    for (let i = 0; i < slotDates.length; i += 1) {\n        let date = slotDates[i];\n        let isWeekStart = tDateProfile.isWeekStarts[i];\n        for (let row = 0; row < formats.length; row += 1) {\n            let format = formats[row];\n            let rowCells = cellRows[row];\n            let leadingCell = rowCells[rowCells.length - 1];\n            let isLastRow = row === formats.length - 1;\n            let isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n            let newCell = null;\n            let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n            if (isSuperRow) {\n                let text = dateEnv.format(date, format);\n                if (!leadingCell || (leadingCell.text !== text)) {\n                    newCell = buildCellObject(date, text, rowUnit);\n                }\n                else {\n                    leadingCell.colspan += 1;\n                }\n            }\n            else if (!leadingCell ||\n                isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n                let text = dateEnv.format(date, format);\n                newCell = buildCellObject(date, text, rowUnit);\n            }\n            else {\n                leadingCell.colspan += 1;\n            }\n            if (newCell) {\n                newCell.weekStart = isWeekStart;\n                rowCells.push(newCell);\n            }\n        }\n    }\n    return cellRows;\n}\nfunction buildCellObject(date, text, rowUnit) {\n    return { date, text, rowUnit, colspan: 1, isWeekStart: false };\n}\n\nclass TimelineHeaderTh extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n        this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n    }\n    render() {\n        let { props, context } = this;\n        let { dateEnv, options } = context;\n        let { cell, dateProfile, tDateProfile } = props;\n        // the cell.rowUnit is f'd\n        // giving 'month' for a 3-day view\n        // workaround: to infer day, do NOT time\n        let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n        let renderProps = this.refineRenderProps({\n            level: props.rowLevel,\n            dateMarker: cell.date,\n            text: cell.text,\n            dateEnv: context.dateEnv,\n            viewApi: context.viewApi,\n        });\n        return (createElement(ContentContainer, { elTag: \"th\", elClasses: [\n                'fc-timeline-slot',\n                'fc-timeline-slot-label',\n                cell.isWeekStart && 'fc-timeline-slot-em',\n                ...( // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n                cell.rowUnit === 'time' ?\n                    getSlotClassNames(dateMeta, context.theme) :\n                    getDayClassNames(dateMeta, context.theme)),\n            ], elAttrs: {\n                colSpan: cell.colspan,\n                'data-date': dateEnv.formatIso(cell.date, {\n                    omitTime: !tDateProfile.isTimeScale,\n                    omitTimeZoneOffset: true,\n                }),\n            }, renderProps: renderProps, generatorName: \"slotLabelContent\", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => (createElement(\"div\", { className: \"fc-timeline-slot-frame\", style: { height: props.rowInnerHeight } },\n            createElement(InnerContent, { elTag: \"a\", elClasses: [\n                    'fc-timeline-slot-cushion',\n                    'fc-scrollgrid-sync-inner',\n                    props.isSticky && 'fc-sticky',\n                ], elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit) })))));\n    }\n}\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n    return (rowUnit && rowUnit !== 'time')\n        ? buildNavLinkAttrs(context, cellDate, rowUnit)\n        : {};\n}\nfunction renderInnerContent(renderProps) {\n    return renderProps.text;\n}\nfunction refineRenderProps(input) {\n    return {\n        level: input.level,\n        date: input.dateEnv.toDate(input.dateMarker),\n        view: input.viewApi,\n        text: input.text,\n    };\n}\n\nclass TimelineHeaderRows extends BaseComponent {\n    render() {\n        let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props;\n        let { cellRows } = tDateProfile;\n        return (createElement(Fragment, null, cellRows.map((rowCells, rowLevel) => {\n            let isLast = rowLevel === cellRows.length - 1;\n            let isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n            let classNames = [\n                'fc-timeline-header-row',\n                isChrono ? 'fc-timeline-header-row-chrono' : '',\n            ];\n            return ( // eslint-disable-next-line react/no-array-index-key\n            createElement(\"tr\", { key: rowLevel, className: classNames.join(' ') }, rowCells.map((cell) => (createElement(TimelineHeaderTh, { key: cell.date.toISOString(), cell: cell, rowLevel: rowLevel, dateProfile: dateProfile, tDateProfile: tDateProfile, todayRange: todayRange, nowDate: nowDate, rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel], isSticky: !isLast })))));\n        })));\n    }\n}\n\nclass TimelineCoords {\n    constructor(slatRootEl, // okay to expose?\n    slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n        this.slatRootEl = slatRootEl;\n        this.dateProfile = dateProfile;\n        this.tDateProfile = tDateProfile;\n        this.dateEnv = dateEnv;\n        this.isRtl = isRtl;\n        this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal\n        false);\n        // for the inner divs within the slats\n        // used for event rendering and scrollTime, to disregard slat border\n        this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal\n        false);\n    }\n    isDateInRange(date) {\n        return rangeContainsMarker(this.dateProfile.currentRange, date);\n    }\n    // results range from negative width of area to 0\n    dateToCoord(date) {\n        let { tDateProfile } = this;\n        let snapCoverage = this.computeDateSnapCoverage(date);\n        let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n        let slotIndex = Math.floor(slotCoverage);\n        slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n        let partial = slotCoverage - slotIndex;\n        let { innerCoordCache, outerCoordCache } = this;\n        if (this.isRtl) {\n            return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] -\n                (innerCoordCache.getWidth(slotIndex) * partial));\n        }\n        return (outerCoordCache.lefts[slotIndex] +\n            (innerCoordCache.getWidth(slotIndex) * partial));\n    }\n    rangeToCoords(range) {\n        return {\n            start: this.dateToCoord(range.start),\n            end: this.dateToCoord(range.end),\n        };\n    }\n    durationToCoord(duration) {\n        let { dateProfile, tDateProfile, dateEnv, isRtl } = this;\n        let coord = 0;\n        if (dateProfile) {\n            let date = dateEnv.add(dateProfile.activeRange.start, duration);\n            if (!tDateProfile.isTimeScale) {\n                date = startOfDay(date);\n            }\n            coord = this.dateToCoord(date);\n            // hack to overcome the left borders of non-first slat\n            if (!isRtl && coord) {\n                coord += 1;\n            }\n        }\n        return coord;\n    }\n    coordFromLeft(coord) {\n        if (this.isRtl) {\n            return this.outerCoordCache.originClientRect.width - coord;\n        }\n        return coord;\n    }\n    // returned value is between 0 and the number of snaps\n    computeDateSnapCoverage(date) {\n        return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n    }\n}\n// returned value is between 0 and the number of snaps\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n    let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n    if (snapDiff < 0) {\n        return 0;\n    }\n    if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n        return tDateProfile.snapCnt;\n    }\n    let snapDiffInt = Math.floor(snapDiff);\n    let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n    if (isInt(snapCoverage)) { // not an in-between value\n        snapCoverage += snapDiff - snapDiffInt; // add the remainder\n    }\n    else {\n        // a fractional value, meaning the date is not visible\n        // always round up in this case. works for start AND end dates in a range.\n        snapCoverage = Math.ceil(snapCoverage);\n    }\n    return snapCoverage;\n}\nfunction coordToCss(hcoord, isRtl) {\n    if (hcoord === null) {\n        return { left: '', right: '' };\n    }\n    if (isRtl) {\n        return { right: hcoord, left: '' };\n    }\n    return { left: hcoord, right: '' };\n}\nfunction coordsToCss(hcoords, isRtl) {\n    if (!hcoords) {\n        return { left: '', right: '' };\n    }\n    if (isRtl) {\n        return { right: hcoords.start, left: -hcoords.end };\n    }\n    return { left: hcoords.start, right: -hcoords.end };\n}\n\nclass TimelineHeader extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n    }\n    render() {\n        let { props, context } = this;\n        // TODO: very repetitive\n        // TODO: make part of tDateProfile?\n        let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;\n        // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n        let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n        return (createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(\"div\", { className: \"fc-timeline-header\", ref: this.rootElRef },\n            createElement(\"table\", { \"aria-hidden\": true, className: \"fc-scrollgrid-sync-table\", style: { minWidth: props.tableMinWidth, width: props.clientWidth } },\n                props.tableColGroupNode,\n                createElement(\"tbody\", null,\n                    createElement(TimelineHeaderRows, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, rowInnerHeights: props.rowInnerHeights }))),\n            context.options.nowIndicator && (\n            // need to have a container regardless of whether the current view has a visible now indicator\n            // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n            // this issue doesn't happen for the timeline body however (\n            createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" }, (slatCoords && slatCoords.isDateInRange(nowDate)) && (createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-arrow'], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: true, date: nowDate }))))))));\n    }\n    componentDidMount() {\n        this.updateSize();\n    }\n    componentDidUpdate() {\n        this.updateSize();\n    }\n    updateSize() {\n        if (this.props.onMaxCushionWidth) {\n            this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n        }\n    }\n    computeMaxCushionWidth() {\n        return Math.max(...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map((el) => el.getBoundingClientRect().width));\n    }\n}\n\nclass TimelineSlatCell extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { dateEnv, options, theme } = context;\n        let { date, tDateProfile, isEm } = props;\n        let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n        let renderProps = Object.assign(Object.assign({ date: dateEnv.toDate(props.date) }, dateMeta), { view: context.viewApi });\n        return (createElement(ContentContainer, { elTag: \"td\", elRef: props.elRef, elClasses: [\n                'fc-timeline-slot',\n                'fc-timeline-slot-lane',\n                isEm && 'fc-timeline-slot-em',\n                tDateProfile.isTimeScale ? (isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ?\n                    'fc-timeline-slot-major' :\n                    'fc-timeline-slot-minor') : '',\n                ...(props.isDay ?\n                    getDayClassNames(dateMeta, theme) :\n                    getSlotClassNames(dateMeta, theme)),\n            ], elAttrs: {\n                'data-date': dateEnv.formatIso(date, {\n                    omitTimeZoneOffset: true,\n                    omitTime: !tDateProfile.isTimeScale,\n                }),\n            }, renderProps: renderProps, generatorName: \"slotLaneContent\", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\" }))));\n    }\n}\n\nclass TimelineSlatsBody extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { tDateProfile, cellElRefs } = props;\n        let { slotDates, isWeekStarts } = tDateProfile;\n        let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n        return (createElement(\"tbody\", null,\n            createElement(\"tr\", null, slotDates.map((slotDate, i) => {\n                let key = slotDate.toISOString();\n                return (createElement(TimelineSlatCell, { key: key, elRef: cellElRefs.createRef(key), date: slotDate, dateProfile: props.dateProfile, tDateProfile: tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isEm: isWeekStarts[i], isDay: isDay }));\n            }))));\n    }\n}\n\nclass TimelineSlats extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = createRef();\n        this.cellElRefs = new RefMap();\n        this.handleScrollRequest = (request) => {\n            let { onScrollLeftRequest } = this.props;\n            let { coords } = this;\n            if (onScrollLeftRequest && coords) {\n                if (request.time) {\n                    let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n                    onScrollLeftRequest(scrollLeft);\n                }\n                return true;\n            }\n            return null; // best?\n        };\n    }\n    render() {\n        let { props, context } = this;\n        return (createElement(\"div\", { className: \"fc-timeline-slots\", ref: this.rootElRef },\n            createElement(\"table\", { \"aria-hidden\": true, className: context.theme.getClass('table'), style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                } },\n                props.tableColGroupNode,\n                createElement(TimelineSlatsBody, { cellElRefs: this.cellElRefs, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange }))));\n    }\n    componentDidMount() {\n        this.updateSizing();\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n    componentDidUpdate(prevProps) {\n        this.updateSizing();\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n    componentWillUnmount() {\n        this.scrollResponder.detach();\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    }\n    updateSizing() {\n        let { props, context } = this;\n        if (props.clientWidth !== null && // is sizing stable?\n            this.scrollResponder\n        // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n        ) {\n            let rootEl = this.rootElRef.current;\n            if (rootEl.offsetWidth) { // not hidden by css\n                this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n                if (props.onCoords) {\n                    props.onCoords(this.coords);\n                }\n                this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n            }\n        }\n    }\n    positionToHit(leftPosition) {\n        let { outerCoordCache } = this.coords;\n        let { dateEnv, isRtl } = this.context;\n        let { tDateProfile } = this.props;\n        let slatIndex = outerCoordCache.leftToIndex(leftPosition);\n        if (slatIndex != null) {\n            // somewhat similar to what TimeGrid does. consolidate?\n            let slatWidth = outerCoordCache.getWidth(slatIndex);\n            let partial = isRtl ?\n                (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth :\n                (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n            let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n            let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n            let end = dateEnv.add(start, tDateProfile.snapDuration);\n            return {\n                dateSpan: {\n                    range: { start, end },\n                    allDay: !this.props.tDateProfile.isTimeScale,\n                },\n                dayEl: this.cellElRefs.currentMap[slatIndex],\n                left: outerCoordCache.lefts[slatIndex],\n                right: outerCoordCache.rights[slatIndex],\n            };\n        }\n        return null;\n    }\n}\nfunction collectCellEls(elMap, slotDates) {\n    return slotDates.map((slotDate) => {\n        let key = slotDate.toISOString();\n        return elMap[key];\n    });\n}\n\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n    let hcoords = [];\n    if (timelineCoords) {\n        for (let seg of segs) {\n            let res = timelineCoords.rangeToCoords(seg);\n            let start = Math.round(res.start); // for barely-overlapping collisions\n            let end = Math.round(res.end); //\n            if (end - start < minWidth) {\n                end = start + minWidth;\n            }\n            hcoords.push({ start, end });\n        }\n    }\n    return hcoords;\n}\nfunction computeFgSegPlacements(segs, segHCoords, // might not have for every seg\neventInstanceHeights, // might not have for every seg\nmoreLinkHeights, // might not have for every more-link\nstrictOrder, maxStackCnt) {\n    let segInputs = [];\n    let crudePlacements = []; // when we don't know dims\n    for (let i = 0; i < segs.length; i += 1) {\n        let seg = segs[i];\n        let instanceId = seg.eventRange.instance.instanceId;\n        let height = eventInstanceHeights[instanceId];\n        let hcoords = segHCoords[i];\n        if (height && hcoords) {\n            segInputs.push({\n                index: i,\n                span: hcoords,\n                thickness: height,\n            });\n        }\n        else {\n            crudePlacements.push({\n                seg,\n                hcoords,\n                top: null,\n            });\n        }\n    }\n    let hierarchy = new SegHierarchy();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let hiddenPlacements = hiddenEntries.map((entry) => ({\n        seg: segs[entry.index],\n        hcoords: entry.span,\n        top: null,\n    }));\n    let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n    let moreLinkInputs = [];\n    let moreLinkCrudePlacements = [];\n    const extractSeg = (entry) => segs[entry.index];\n    for (let i = 0; i < hiddenGroups.length; i += 1) {\n        let hiddenGroup = hiddenGroups[i];\n        let sortedSegs = hiddenGroup.entries.map(extractSeg);\n        let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n        if (height != null) {\n            // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n            moreLinkInputs.push({\n                index: segs.length + i,\n                thickness: height,\n                span: hiddenGroup.span,\n            });\n        }\n        else {\n            moreLinkCrudePlacements.push({\n                seg: sortedSegs,\n                hcoords: hiddenGroup.span,\n                top: null,\n            });\n        }\n    }\n    // add more-links into the hierarchy, but don't limit\n    hierarchy.maxStackCnt = -1;\n    hierarchy.addSegs(moreLinkInputs);\n    let visibleRects = hierarchy.toRects();\n    let visiblePlacements = [];\n    let maxHeight = 0;\n    for (let rect of visibleRects) {\n        let segIndex = rect.index;\n        visiblePlacements.push({\n            seg: segIndex < segs.length\n                ? segs[segIndex] // a real seg\n                : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n            hcoords: rect.span,\n            top: rect.levelCoord,\n        });\n        maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n    }\n    return [\n        visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),\n        maxHeight,\n    ];\n}\n\nclass TimelineLaneBg extends BaseComponent {\n    render() {\n        let { props } = this;\n        let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n        return props.timelineCoords && (createElement(\"div\", { className: \"fc-timeline-bg\" },\n            this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'),\n            this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'),\n            this.renderSegs(highlightSeg, props.timelineCoords, 'highlight')));\n    }\n    renderSegs(segs, timelineCoords, fillType) {\n        let { todayRange, nowDate } = this.props;\n        let { isRtl } = this.context;\n        let segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n        let children = segs.map((seg, i) => {\n            let hcoords = segHCoords[i];\n            let hStyle = coordsToCss(hcoords, isRtl);\n            return (createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-timeline-bg-harness\", style: hStyle }, fillType === 'bg-event' ?\n                createElement(BgEvent, Object.assign({ seg: seg }, getSegMeta(seg, todayRange, nowDate))) :\n                renderFill(fillType)));\n        });\n        return createElement(Fragment, null, children);\n    }\n}\n\nclass TimelineLaneSlicer extends Slicer {\n    sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n        let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n        let segs = [];\n        // protect against when the span is entirely in an invalid date region\n        if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv)\n            < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n            // intersect the footprint's range with the grid's range\n            let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n            if (slicedRange) {\n                segs.push({\n                    start: slicedRange.start,\n                    end: slicedRange.end,\n                    isStart: slicedRange.start.valueOf() === normalRange.start.valueOf()\n                        && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n                    isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf()\n                        && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator),\n                });\n            }\n        }\n        return segs;\n    }\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n    hour: 'numeric',\n    minute: '2-digit',\n    omitZeroMinute: true,\n    meridiem: 'narrow',\n});\nclass TimelineEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        return (createElement(StandardEvent, Object.assign({}, props, { elClasses: ['fc-timeline-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TIME_FORMAT, defaultDisplayEventTime: !props.isTimeScale })));\n    }\n}\n\nclass TimelineLaneMoreLink extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { hiddenSegs, placement, resourceId } = props;\n        let { top, hcoords } = placement;\n        let isVisible = hcoords && top !== null;\n        let hStyle = coordsToCss(hcoords, context.isRtl);\n        let extraDateSpan = resourceId ? { resourceId } : {};\n        return (createElement(MoreLinkContainer, { elRef: props.elRef, elClasses: ['fc-timeline-more-link'], elStyle: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle), allDayDate: null, moreCnt: hiddenSegs.length, allSegs: hiddenSegs, hiddenSegs: hiddenSegs, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: extraDateSpan, popoverContent: () => (createElement(Fragment, null, hiddenSegs.map((seg) => {\n                let instanceId = seg.eventRange.instance.instanceId;\n                return (createElement(\"div\", { key: instanceId, style: { visibility: props.isForcedInvisible[instanceId] ? 'hidden' : '' } },\n                    createElement(TimelineEvent, Object.assign({ isTimeScale: props.isTimeScale, seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n            }))) }, (InnerContent) => (createElement(InnerContent, { elTag: \"div\", elClasses: ['fc-timeline-more-link-inner', 'fc-sticky'] }))));\n    }\n}\n\nclass TimelineLane extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.slicer = new TimelineLaneSlicer();\n        this.sortEventSegs = memoize(sortEventSegs);\n        this.harnessElRefs = new RefMap();\n        this.moreElRefs = new RefMap();\n        this.innerElRef = createRef();\n        // TODO: memoize event positioning\n        this.state = {\n            eventInstanceHeights: {},\n            moreLinkHeights: {},\n        };\n        this.handleResize = (isForced) => {\n            if (isForced) {\n                this.updateSize();\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let { dateProfile, tDateProfile } = props;\n        let slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...\n        dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n        let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) ||\n            (slicedProps.eventResize ? slicedProps.eventResize.segs : null) ||\n            [];\n        let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n        let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n        let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);\n        let isForcedInvisible = // TODO: more convenient\n         (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) ||\n            (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) ||\n            {};\n        return (createElement(Fragment, null,\n            createElement(TimelineLaneBg, { businessHourSegs: slicedProps.businessHourSegs, bgEventSegs: slicedProps.bgEventSegs, timelineCoords: props.timelineCoords, eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [] /* bad new empty array? */, dateSelectionSegs: slicedProps.dateSelectionSegs, nowDate: props.nowDate, todayRange: props.todayRange }),\n            createElement(\"div\", { className: \"fc-timeline-events fc-scrollgrid-sync-inner\", ref: this.innerElRef, style: { height: fgHeight } },\n                this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false),\n                this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false))));\n    }\n    componentDidMount() {\n        this.updateSize();\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        if (prevProps.eventStore !== this.props.eventStore || // external thing changed?\n            prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n            prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n        ) {\n            this.updateSize();\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateSize() {\n        let { props } = this;\n        let { timelineCoords } = props;\n        const innerEl = this.innerElRef.current;\n        if (props.onHeightChange) {\n            props.onHeightChange(innerEl, false);\n        }\n        if (timelineCoords) {\n            this.setState({\n                eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => (Math.round(harnessEl.getBoundingClientRect().height))),\n                moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => (Math.round(moreEl.getBoundingClientRect().height))),\n            }, () => {\n                if (props.onHeightChange) {\n                    props.onHeightChange(innerEl, true);\n                }\n            });\n        }\n        // hack\n        if (props.syncParentMinHeight) {\n            innerEl.parentElement.style.minHeight = innerEl.style.height;\n        }\n    }\n    renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { harnessElRefs, moreElRefs, props, context } = this;\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        return (createElement(Fragment, null, segPlacements.map((segPlacement) => {\n            let { seg, hcoords, top } = segPlacement;\n            if (Array.isArray(seg)) { // a more-link\n                let isoStr = buildIsoString(computeEarliestSegStart(seg));\n                return (createElement(TimelineLaneMoreLink, { key: 'm:' + isoStr /* \"m\" for \"more\" */, elRef: moreElRefs.createRef(isoStr), hiddenSegs: seg, placement: segPlacement, dateProfile: props.dateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isTimeScale: props.tDateProfile.isTimeScale, eventSelection: props.eventSelection, resourceId: props.resourceId, isForcedInvisible: isForcedInvisible }));\n            }\n            let instanceId = seg.eventRange.instance.instanceId;\n            let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n            let hStyle = coordsToCss(hcoords, context.isRtl);\n            return (createElement(\"div\", { key: 'e:' + instanceId /* \"e\" for \"event\" */, ref: isMirror ? null : harnessElRefs.createRef(instanceId), className: \"fc-timeline-event-harness\", style: Object.assign({ visibility: isVisible ? '' : 'hidden', top: top || 0 }, hStyle) },\n                createElement(TimelineEvent, Object.assign({ isTimeScale: props.tDateProfile.isTimeScale, seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === props.eventSelection /* TODO: bad for mirror? */ }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n        })));\n    }\n}\nTimelineLane.addStateEquality({\n    eventInstanceHeights: isPropsEqual,\n    moreLinkHeights: isPropsEqual,\n});\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n    if (!mirrorSegs.length || !timelineCoords) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg) => ({\n        seg,\n        hcoords: timelineCoords.rangeToCoords(seg),\n        top: topsByInstanceId[seg.eventRange.instance.instanceId],\n    }));\n}\nfunction buildAbsoluteTopHash(placements) {\n    let topsByInstanceId = {};\n    for (let placement of placements) {\n        let { seg } = placement;\n        if (!Array.isArray(seg)) { // doesn't represent a more-link\n            topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n        }\n    }\n    return topsByInstanceId;\n}\n\nclass TimelineGrid extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.slatsRef = createRef();\n        this.state = {\n            coords: null,\n        };\n        this.handeEl = (el) => {\n            if (el) {\n                this.context.registerInteractiveComponent(this, { el });\n            }\n            else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n        this.handleCoords = (coords) => {\n            this.setState({ coords });\n            if (this.props.onSlatCoords) {\n                this.props.onSlatCoords(coords);\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let { dateProfile, tDateProfile } = props;\n        let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n        return (createElement(\"div\", { className: \"fc-timeline-body\", ref: this.handeEl, style: {\n                minWidth: props.tableMinWidth,\n                height: props.clientHeight,\n                width: props.clientWidth,\n            } },\n            createElement(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => (createElement(Fragment, null,\n                createElement(TimelineSlats, { ref: this.slatsRef, dateProfile: dateProfile, tDateProfile: tDateProfile, nowDate: nowDate, todayRange: todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleCoords, onScrollLeftRequest: props.onScrollLeftRequest }),\n                createElement(TimelineLane, { dateProfile: dateProfile, tDateProfile: props.tDateProfile, nowDate: nowDate, todayRange: todayRange, nextDayThreshold: options.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: state.coords, syncParentMinHeight: true }),\n                (options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate)) && (createElement(\"div\", { className: \"fc-timeline-now-indicator-container\" },\n                    createElement(NowIndicatorContainer, { elClasses: ['fc-timeline-now-indicator-line'], elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate }))))))));\n    }\n    // Hit System\n    // ------------------------------------------------------------------------------------------\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let slats = this.slatsRef.current;\n        let slatHit = slats.positionToHit(positionLeft);\n        if (slatHit) {\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: slatHit.dateSpan,\n                rect: {\n                    left: slatHit.left,\n                    right: slatHit.right,\n                    top: 0,\n                    bottom: elHeight,\n                },\n                dayEl: slatHit.dayEl,\n                layer: 0,\n            };\n        }\n        return null;\n    }\n}\n\nclass TimelineView extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n        this.scrollGridRef = createRef();\n        this.state = {\n            slatCoords: null,\n            slotCushionMaxWidth: null,\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n        };\n        this.handleScrollLeftRequest = (scrollLeft) => {\n            let scrollGrid = this.scrollGridRef.current;\n            scrollGrid.forceScrollLeft(0, scrollLeft);\n        };\n        this.handleMaxCushionWidth = (slotCushionMaxWidth) => {\n            this.setState({\n                slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth), // for less rerendering TODO: DRY\n            });\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n        let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n        let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n        let { slotMinWidth } = options;\n        let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n        let sections = [\n            {\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunks: [{\n                        key: 'timeline',\n                        content: (contentArg) => (createElement(TimelineHeader, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, slatCoords: state.slatCoords, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth })),\n                    }],\n            },\n            {\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunks: [{\n                        key: 'timeline',\n                        content: (contentArg) => (createElement(TimelineGrid, Object.assign({}, props, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile: tDateProfile, onSlatCoords: this.handleSlatCoords, onScrollLeftRequest: this.handleScrollLeftRequest }))),\n                    }],\n            },\n        ];\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: 'footer',\n                key: 'footer',\n                isSticky: true,\n                chunks: [{\n                        key: 'timeline',\n                        content: renderScrollShim,\n                    }],\n            });\n        }\n        return (createElement(ViewContainer, { elClasses: [\n                'fc-timeline',\n                options.eventOverlap === false ?\n                    'fc-timeline-overlap-disabled' :\n                    '',\n            ], viewSpec: context.viewSpec },\n            createElement(ScrollGrid, { ref: this.scrollGridRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [\n                    { cols: slatCols },\n                ], sections: sections })));\n    }\n    computeFallbackSlotMinWidth(tDateProfile) {\n        return Math.max(30, ((this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel));\n    }\n}\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n    return [{\n            span: tDateProfile.slotCnt,\n            minWidth: slotMinWidth || 1, // needs to be a non-zero number to trigger horizontal scrollbars!??????\n        }];\n}\n\nvar css_248z = \".fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;pointer-events:none;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:\\\"\\\";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}\";\ninjectStyles(css_248z);\n\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}