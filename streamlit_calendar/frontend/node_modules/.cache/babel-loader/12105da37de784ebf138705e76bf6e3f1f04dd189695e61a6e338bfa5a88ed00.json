{"ast":null,"code":"import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n  let rect = scrollEl.getBoundingClientRect();\n  let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n  return {\n    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n    top: rect.top + edges.borderTop - scrollEl.scrollTop\n  };\n}\nfunction getScrollFromLeftEdge(el) {\n  let scrollLeft = el.scrollLeft;\n  let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'negative':\n        scrollLeft *= -1;\n      // convert to 'reverse'. fall through...\n      case 'reverse':\n        // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n        scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n    }\n  }\n  return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n  let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'reverse':\n        scrollLeft = el.scrollWidth - scrollLeft;\n        break;\n      case 'negative':\n        scrollLeft = -(el.scrollWidth - scrollLeft);\n        break;\n    }\n  }\n  el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nlet _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n  let el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '-1000px';\n  el.style.width = '1px';\n  el.style.height = '1px';\n  el.style.overflow = 'scroll';\n  el.style.direction = 'rtl';\n  el.style.fontSize = '100px';\n  el.innerHTML = 'A';\n  document.body.appendChild(el);\n  let system;\n  if (el.scrollLeft > 0) {\n    system = 'positive'; // scroll is a positive number from the left edge\n  } else {\n    el.scrollLeft = 1;\n    if (el.scrollLeft > 0) {\n      system = 'reverse'; // scroll is a positive number from the right edge\n    } else {\n      system = 'negative'; // scroll is a negative number from the right edge\n    }\n  }\n\n  removeElement(el);\n  return system;\n}\nconst STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nclass StickyScrolling {\n  constructor(scrollEl, isRtl) {\n    this.scrollEl = scrollEl;\n    this.isRtl = isRtl;\n    this.updateSize = () => {\n      let {\n        scrollEl\n      } = this;\n      let els = findElements(scrollEl, STICKY_SELECTOR);\n      let elGeoms = this.queryElGeoms(els);\n      let viewportWidth = scrollEl.clientWidth;\n      assignStickyPositions(els, elGeoms, viewportWidth);\n    };\n  }\n  queryElGeoms(els) {\n    let {\n      scrollEl,\n      isRtl\n    } = this;\n    let canvasOrigin = getScrollCanvasOrigin(scrollEl);\n    let elGeoms = [];\n    for (let el of els) {\n      let parentBound = translateRect(computeInnerRect(el.parentNode, true, true),\n      // weird way to call this!!!\n      -canvasOrigin.left, -canvasOrigin.top);\n      let elRect = el.getBoundingClientRect();\n      let computedStyles = window.getComputedStyle(el);\n      let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n      let naturalBound = null;\n      if (textAlign === 'start') {\n        textAlign = isRtl ? 'right' : 'left';\n      } else if (textAlign === 'end') {\n        textAlign = isRtl ? 'left' : 'right';\n      }\n      if (computedStyles.position !== 'sticky') {\n        naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0),\n        // could be 'auto'\n        -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n      }\n      elGeoms.push({\n        parentBound,\n        naturalBound,\n        elWidth: elRect.width,\n        elHeight: elRect.height,\n        textAlign\n      });\n    }\n    return elGeoms;\n  }\n}\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n  els.forEach((el, i) => {\n    let {\n      textAlign,\n      elWidth,\n      parentBound\n    } = elGeoms[i];\n    let parentWidth = parentBound.right - parentBound.left;\n    let left;\n    if (textAlign === 'center' && parentWidth > viewportWidth) {\n      left = (viewportWidth - elWidth) / 2;\n    } else {\n      // if parent container can be completely in view, we don't need stickiness\n      left = '';\n    }\n    applyStyle(el, {\n      left,\n      right: left,\n      top: 0\n    });\n  });\n}\nclass ClippedScroller extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.elRef = createRef();\n    this.state = {\n      xScrollbarWidth: 0,\n      yScrollbarWidth: 0\n    };\n    this.handleScroller = scroller => {\n      this.scroller = scroller;\n      setRef(this.props.scrollerRef, scroller);\n    };\n    this.handleSizing = () => {\n      let {\n        props\n      } = this;\n      if (props.overflowY === 'scroll-hidden') {\n        this.setState({\n          yScrollbarWidth: this.scroller.getYScrollbarWidth()\n        });\n      }\n      if (props.overflowX === 'scroll-hidden') {\n        this.setState({\n          xScrollbarWidth: this.scroller.getXScrollbarWidth()\n        });\n      }\n    };\n  }\n  render() {\n    let {\n      props,\n      state,\n      context\n    } = this;\n    let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n    let overcomeLeft = 0;\n    let overcomeRight = 0;\n    let overcomeBottom = 0;\n    let {\n      overflowX,\n      overflowY\n    } = props;\n    if (props.forPrint) {\n      overflowX = 'visible';\n      overflowY = 'visible';\n    }\n    if (overflowX === 'scroll-hidden') {\n      overcomeBottom = state.xScrollbarWidth;\n    }\n    if (overflowY === 'scroll-hidden') {\n      if (state.yScrollbarWidth != null) {\n        if (isScrollbarOnLeft) {\n          overcomeLeft = state.yScrollbarWidth;\n        } else {\n          overcomeRight = state.yScrollbarWidth;\n        }\n      }\n    }\n    return createElement(\"div\", {\n      ref: this.elRef,\n      className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')\n    }, createElement(Scroller, {\n      ref: this.handleScroller,\n      elRef: this.props.scrollerElRef,\n      overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX,\n      overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY,\n      overcomeLeft: overcomeLeft,\n      overcomeRight: overcomeRight,\n      overcomeBottom: overcomeBottom,\n      maxHeight: typeof props.maxHeight === 'number' ? props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0) : '',\n      liquid: props.liquid,\n      liquidIsAbsolute: true\n    }, props.children));\n  }\n  componentDidMount() {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    if (this.props.forPrint && !prevProps.forPrint) {\n      return {\n        simulateScrollLeft: this.scroller.el.scrollLeft\n      };\n    }\n    return {};\n  }\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    const {\n      props,\n      scroller: {\n        el: scrollerEl\n      }\n    } = this;\n    if (!isPropsEqual(prevProps, props)) {\n      // an external change?\n      this.handleSizing();\n    }\n    if (snapshot.simulateScrollLeft !== undefined) {\n      scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n    } else if (!props.forPrint && prevProps.forPrint) {\n      const restoredScrollLeft = -parseInt(scrollerEl.style.left);\n      scrollerEl.style.left = '';\n      scrollerEl.scrollLeft = restoredScrollLeft;\n    }\n  }\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing);\n  }\n  needsXScrolling() {\n    return this.scroller.needsXScrolling();\n  }\n  needsYScrolling() {\n    return this.scroller.needsYScrolling();\n  }\n}\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nclass ScrollListener {\n  constructor(el) {\n    this.el = el;\n    this.emitter = new Emitter();\n    this.isScrolling = false;\n    this.isTouching = false; // user currently has finger down?\n    this.isRecentlyWheeled = false;\n    this.isRecentlyScrolled = false;\n    this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n    this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n    // Handlers\n    // ----------------------------------------------------------------------------------------------\n    this.handleScroll = () => {\n      this.startScroll();\n      this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\n      this.isRecentlyScrolled = true;\n      this.scrollWaiter.request(500);\n    };\n    // will fire *before* the scroll event is fired (might not cause a scroll)\n    this.handleWheel = () => {\n      this.isRecentlyWheeled = true;\n      this.wheelWaiter.request(500);\n    };\n    // will fire *before* the scroll event is fired (might not cause a scroll)\n    this.handleTouchStart = () => {\n      this.isTouching = true;\n    };\n    this.handleTouchEnd = () => {\n      this.isTouching = false;\n      // if the user ended their touch, and the scroll area wasn't moving,\n      // we consider this to be the end of the scroll.\n      if (!this.isRecentlyScrolled) {\n        this.endScroll(); // won't fire if already ended\n      }\n    };\n\n    el.addEventListener('scroll', this.handleScroll);\n    el.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.addEventListener('touchend', this.handleTouchEnd);\n    for (let eventName of WHEEL_EVENT_NAMES) {\n      el.addEventListener(eventName, this.handleWheel);\n    }\n  }\n  destroy() {\n    let {\n      el\n    } = this;\n    el.removeEventListener('scroll', this.handleScroll);\n    el.removeEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.removeEventListener('touchend', this.handleTouchEnd);\n    for (let eventName of WHEEL_EVENT_NAMES) {\n      el.removeEventListener(eventName, this.handleWheel);\n    }\n  }\n  // Start / Stop\n  // ----------------------------------------------------------------------------------------------\n  startScroll() {\n    if (!this.isScrolling) {\n      this.isScrolling = true;\n      this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n    }\n  }\n  endScroll() {\n    if (this.isScrolling) {\n      this.emitter.trigger('scrollEnd');\n      this.isScrolling = false;\n      this.isRecentlyScrolled = true;\n      this.isRecentlyWheeled = false;\n      this.scrollWaiter.clear();\n      this.wheelWaiter.clear();\n    }\n  }\n  _handleScrollWaited() {\n    this.isRecentlyScrolled = false;\n    // only end the scroll if not currently touching.\n    // if touching, the scrolling will end later, on touchend.\n    if (!this.isTouching) {\n      this.endScroll(); // won't fire if already ended\n    }\n  }\n\n  _handleWheelWaited() {\n    this.isRecentlyWheeled = false;\n  }\n}\nclass ScrollSyncer {\n  constructor(isVertical, scrollEls) {\n    this.isVertical = isVertical;\n    this.scrollEls = scrollEls;\n    this.isPaused = false;\n    this.scrollListeners = scrollEls.map(el => this.bindScroller(el));\n  }\n  destroy() {\n    for (let scrollListener of this.scrollListeners) {\n      scrollListener.destroy();\n    }\n  }\n  bindScroller(el) {\n    let {\n      scrollEls,\n      isVertical\n    } = this;\n    let scrollListener = new ScrollListener(el);\n    const onScroll = (isWheel, isTouch) => {\n      if (!this.isPaused) {\n        if (!this.masterEl || this.masterEl !== el && (isWheel || isTouch)) {\n          this.assignMaster(el);\n        }\n        if (this.masterEl === el) {\n          // dealing with current\n          for (let otherEl of scrollEls) {\n            if (otherEl !== el) {\n              if (isVertical) {\n                otherEl.scrollTop = el.scrollTop;\n              } else {\n                otherEl.scrollLeft = el.scrollLeft;\n              }\n            }\n          }\n        }\n      }\n    };\n    const onScrollEnd = () => {\n      if (this.masterEl === el) {\n        this.masterEl = null;\n      }\n    };\n    scrollListener.emitter.on('scroll', onScroll);\n    scrollListener.emitter.on('scrollEnd', onScrollEnd);\n    return scrollListener;\n  }\n  assignMaster(el) {\n    this.masterEl = el;\n    for (let scrollListener of this.scrollListeners) {\n      if (scrollListener.el !== el) {\n        scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n      }\n    }\n  }\n  /*\n  will normalize the scrollLeft value\n  */\n  forceScrollLeft(scrollLeft) {\n    this.isPaused = true;\n    for (let listener of this.scrollListeners) {\n      setScrollFromLeftEdge(listener.el, scrollLeft);\n    }\n    this.isPaused = false;\n  }\n  forceScrollTop(top) {\n    this.isPaused = true;\n    for (let listener of this.scrollListeners) {\n      listener.el.scrollTop = top;\n    }\n    this.isPaused = false;\n  }\n}\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nclass ScrollGrid extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n    this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n    this.clippedScrollerRefs = new RefMap();\n    // doesn't hold non-scrolling els used just for padding\n    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n    this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\n    this.scrollSyncersBySection = {};\n    this.scrollSyncersByColumn = {};\n    // for row-height-syncing\n    this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n    this.rowInnerMaxHeightMap = new Map();\n    this.anyRowHeightsChanged = false;\n    this.recentSizingCnt = 0;\n    this.state = {\n      shrinkWidths: [],\n      forceYScrollbars: false,\n      forceXScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {},\n      sectionRowMaxHeights: []\n    };\n    this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\n      if (!this.allowSizing()) {\n        return;\n      }\n      if (!sectionRowMaxHeightsChanged) {\n        // something else changed, probably external\n        this.anyRowHeightsChanged = true;\n      }\n      let otherState = {};\n      // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n      if (isForcedResize || !sectionRowMaxHeightsChanged && !this.rowUnstableMap.size) {\n        otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\n      }\n      this.setState(Object.assign(Object.assign({\n        shrinkWidths: this.computeShrinkWidths()\n      }, this.computeScrollerDims()), otherState), () => {\n        if (!this.rowUnstableMap.size) {\n          this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n        }\n      });\n    };\n\n    this.handleRowHeightChange = (rowEl, isStable) => {\n      let {\n        rowUnstableMap,\n        rowInnerMaxHeightMap\n      } = this;\n      if (!isStable) {\n        rowUnstableMap.set(rowEl, true);\n      } else {\n        rowUnstableMap.delete(rowEl);\n        let innerMaxHeight = getRowInnerMaxHeight(rowEl);\n        if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n          rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n          this.anyRowHeightsChanged = true;\n        }\n        if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n          this.anyRowHeightsChanged = false;\n          this.setState({\n            sectionRowMaxHeights: this.computeSectionRowMaxHeights()\n          });\n        }\n      }\n    };\n  }\n  render() {\n    let {\n      props,\n      state,\n      context\n    } = this;\n    let {\n      shrinkWidths\n    } = state;\n    let colGroupStats = this.compileColGroupStats(props.colGroups.map(colGroup => [colGroup]));\n    let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\n    let classNames = getScrollGridClassNames(props.liquid, context);\n    this.getDims();\n    // TODO: make DRY\n    let sectionConfigs = props.sections;\n    let configCnt = sectionConfigs.length;\n    let configI = 0;\n    let currentConfig;\n    let headSectionNodes = [];\n    let bodySectionNodes = [];\n    let footSectionNodes = [];\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n      configI += 1;\n    }\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n      configI += 1;\n    }\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n      configI += 1;\n    }\n    const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n    const roleAttrs = {\n      role: 'rowgroup'\n    };\n    return createElement('table', {\n      ref: props.elRef,\n      role: 'grid',\n      className: classNames.join(' ')\n    }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n  }\n  renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n    if ('outerContent' in sectionConfig) {\n      return createElement(Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n    return createElement(\"tr\", {\n      key: sectionConfig.key,\n      role: \"presentation\",\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader)));\n  }\n  renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n    if ('outerContent' in chunkConfig) {\n      return createElement(Fragment, {\n        key: chunkConfig.key\n      }, chunkConfig.outerContent);\n    }\n    let {\n      state\n    } = this;\n    let {\n      scrollerClientWidths,\n      scrollerClientHeights\n    } = state;\n    let [sectionCnt, chunksPerSection] = this.getDims();\n    let index = sectionIndex * chunksPerSection + chunkIndex;\n    let sideScrollIndex = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n    let isVScrollSide = chunkIndex === sideScrollIndex;\n    let isLastSection = sectionIndex === sectionCnt - 1;\n    let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n    let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n    let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n    let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n    let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n    let expandRows = sectionConfig.expandRows && chunkVGrow;\n    let tableMinWidth = colGroupStat && colGroupStat.totalColMinWidth || '';\n    let content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth,\n      clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n      clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n      expandRows,\n      syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n      rowSyncHeights: rowHeights,\n      reportRowHeightChange: this.handleRowHeightChange\n    }, isHeader);\n    let overflowX = forceXScrollbars ? isLastSection ? 'scroll' : 'scroll-hidden' : !allowXScrolling ? 'hidden' : isLastSection ? 'auto' : 'scroll-hidden';\n    let overflowY = forceYScrollbars ? isVScrollSide ? 'scroll' : 'scroll-hidden' : !allowYScrolling ? 'hidden' : isVScrollSide ? 'auto' : 'scroll-hidden';\n    // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n    // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n    content = createElement(ClippedScroller, {\n      ref: this.clippedScrollerRefs.createRef(index),\n      scrollerElRef: this.scrollerElRefs.createRef(index),\n      overflowX: overflowX,\n      overflowY: overflowY,\n      forPrint: this.props.forPrint,\n      liquid: chunkVGrow,\n      maxHeight: sectionConfig.maxHeight\n    }, content);\n    return createElement(isHeader ? 'th' : 'td', {\n      key: chunkConfig.key,\n      ref: this.chunkElRefs.createRef(index),\n      role: 'presentation'\n    }, content);\n  }\n  componentDidMount() {\n    this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n    this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n    this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n    this.updateScrollSyncers();\n    this.handleSizing(false);\n    this.context.addResizeHandler(this.handleSizing);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    this.updateScrollSyncers();\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n  }\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing);\n    this.destroyScrollSyncers();\n  }\n  allowSizing() {\n    let now = new Date();\n    if (!this.lastSizingDate || now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n      this.lastSizingDate = now;\n      this.recentSizingCnt = 0;\n      return true;\n    }\n    return (this.recentSizingCnt += 1) <= 10;\n  }\n  computeShrinkWidths() {\n    let colGroupStats = this.compileColGroupStats(this.props.colGroups.map(colGroup => [colGroup]));\n    let [sectionCnt, chunksPerSection] = this.getDims();\n    let cnt = sectionCnt * chunksPerSection;\n    let shrinkWidths = [];\n    colGroupStats.forEach((colGroupStat, i) => {\n      if (colGroupStat.hasShrinkCol) {\n        let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n        shrinkWidths[i] = computeShrinkWidth(chunkEls);\n      }\n    });\n    return shrinkWidths;\n  }\n  // has the side effect of grooming rowInnerMaxHeightMap\n  // TODO: somehow short-circuit if there are no new height changes\n  computeSectionRowMaxHeights() {\n    let newHeightMap = new Map();\n    let [sectionCnt, chunksPerSection] = this.getDims();\n    let sectionRowMaxHeights = [];\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      let sectionConfig = this.props.sections[sectionI];\n      let assignableHeights = []; // chunk, row\n      if (sectionConfig && sectionConfig.syncRowHeights) {\n        let rowHeightsByChunk = [];\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n          let index = sectionI * chunksPerSection + chunkI;\n          let rowHeights = [];\n          let chunkEl = this.chunkElRefs.currentMap[index];\n          if (chunkEl) {\n            rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map(rowEl => {\n              let max = getRowInnerMaxHeight(rowEl);\n              newHeightMap.set(rowEl, max);\n              return max;\n            });\n          } else {\n            rowHeights = [];\n          }\n          rowHeightsByChunk.push(rowHeights);\n        }\n        let rowCnt = rowHeightsByChunk[0].length;\n        let isEqualRowCnt = true;\n        for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n          let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) {\n            // skip outer content\n            isEqualRowCnt = false;\n            break;\n          }\n        }\n        if (!isEqualRowCnt) {\n          let chunkHeightSums = [];\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n          }\n          let maxTotalSum = Math.max(...chunkHeightSums);\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n            let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n            // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n            let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n            // whatever is leftover goes to the first row\n            let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n            let rowInChunkHeights = [];\n            let row = 0;\n            if (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightFirst);\n              row += 1;\n            }\n            while (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightOthers);\n              row += 1;\n            }\n            assignableHeights.push(rowInChunkHeights);\n          }\n        } else {\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            assignableHeights.push([]);\n          }\n          for (let row = 0; row < rowCnt; row += 1) {\n            let rowHeightsAcrossChunks = [];\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              let h = rowHeightsByChunk[chunkI][row];\n              if (h != null) {\n                // protect against outerContent\n                rowHeightsAcrossChunks.push(h);\n              }\n            }\n            let maxHeight = Math.max(...rowHeightsAcrossChunks);\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              assignableHeights[chunkI].push(maxHeight);\n            }\n          }\n        }\n      }\n      sectionRowMaxHeights.push(assignableHeights);\n    }\n    this.rowInnerMaxHeightMap = newHeightMap;\n    return sectionRowMaxHeights;\n  }\n  computeScrollerDims() {\n    let scrollbarWidth = getScrollbarWidths();\n    let [sectionCnt, chunksPerSection] = this.getDims();\n    let sideScrollI = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n    let lastSectionI = sectionCnt - 1;\n    let currentScrollers = this.clippedScrollerRefs.currentMap;\n    let scrollerEls = this.scrollerElRefs.currentMap;\n    let forceYScrollbars = false;\n    let forceXScrollbars = false;\n    let scrollerClientWidths = {};\n    let scrollerClientHeights = {};\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      // along edge\n      let index = sectionI * chunksPerSection + sideScrollI;\n      let scroller = currentScrollers[index];\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n      // along last row\n      let index = lastSectionI * chunksPerSection + chunkI;\n      let scroller = currentScrollers[index];\n      if (scroller && scroller.needsXScrolling()) {\n        forceXScrollbars = true;\n        break;\n      }\n    }\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        let index = sectionI * chunksPerSection + chunkI;\n        let scrollerEl = scrollerEls[index];\n        if (scrollerEl) {\n          // TODO: weird way to get this. need harness b/c doesn't include table borders\n          let harnessEl = scrollerEl.parentNode;\n          scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - (chunkI === sideScrollI && forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n          : 0));\n          scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - (sectionI === lastSectionI && forceXScrollbars ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n          : 0));\n        }\n      }\n    }\n    return {\n      forceYScrollbars,\n      forceXScrollbars,\n      scrollerClientWidths,\n      scrollerClientHeights\n    };\n  }\n  updateStickyScrolling() {\n    let {\n      isRtl\n    } = this.context;\n    let argsByKey = this.scrollerElRefs.getAll().map(scrollEl => [scrollEl, isRtl]);\n    this.getStickyScrolling(argsByKey).forEach(stickyScrolling => stickyScrolling.updateSize());\n  }\n  updateScrollSyncers() {\n    let [sectionCnt, chunksPerSection] = this.getDims();\n    let cnt = sectionCnt * chunksPerSection;\n    let scrollElsBySection = {};\n    let scrollElsByColumn = {};\n    let scrollElMap = this.scrollerElRefs.currentMap;\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      let startIndex = sectionI * chunksPerSection;\n      let endIndex = startIndex + chunksPerSection;\n      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n    }\n\n    for (let col = 0; col < chunksPerSection; col += 1) {\n      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n    }\n\n    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n  }\n  destroyScrollSyncers() {\n    mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n  }\n  getChunkConfigByIndex(index) {\n    let chunksPerSection = this.getDims()[1];\n    let sectionI = Math.floor(index / chunksPerSection);\n    let chunkI = index % chunksPerSection;\n    let sectionConfig = this.props.sections[sectionI];\n    return sectionConfig && sectionConfig.chunks[chunkI];\n  }\n  forceScrollLeft(col, scrollLeft) {\n    let scrollSyncer = this.scrollSyncersByColumn[col];\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollLeft(scrollLeft);\n    }\n  }\n  forceScrollTop(sectionI, scrollTop) {\n    let scrollSyncer = this.scrollSyncersBySection[sectionI];\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollTop(scrollTop);\n    }\n  }\n  _handleChunkEl(chunkEl, key) {\n    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n    if (chunkConfig) {\n      // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.elRef, chunkEl);\n    }\n  }\n  _handleScrollerEl(scrollerEl, key) {\n    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n    if (chunkConfig) {\n      // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.scrollerElRef, scrollerEl);\n    }\n  }\n  getDims() {\n    let sectionCnt = this.props.sections.length;\n    let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n    return [sectionCnt, chunksPerSection];\n  }\n}\nScrollGrid.addStateEquality({\n  shrinkWidths: isArraysEqual,\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\nfunction sumNumbers(numbers) {\n  let sum = 0;\n  for (let n of numbers) {\n    sum += n;\n  }\n  return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n  let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n  if (innerHeights.length) {\n    return Math.max(...innerHeights);\n  }\n  return 0;\n}\nfunction getElHeight(el) {\n  return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\n\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n  let children = colGroupStats.map((colGroupStat, i) => {\n    let width = colGroupStat.width;\n    if (width === 'shrink') {\n      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n    }\n\n    return (\n      // eslint-disable-next-line react/jsx-key\n      createElement(\"col\", {\n        style: {\n          width\n        }\n      })\n    );\n  });\n  return createElement('colgroup', {}, ...children);\n}\nfunction compileColGroupStat(colGroupConfig) {\n  let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n  let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n  let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n  let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n  return {\n    hasShrinkCol,\n    totalColWidth,\n    totalColMinWidth,\n    allowXScrolling,\n    cols: colGroupConfig.cols,\n    width: colGroupConfig.width\n  };\n}\nfunction sumColProp(cols, propName) {\n  let total = 0;\n  for (let col of cols) {\n    let val = col[propName];\n    if (typeof val === 'number') {\n      total += val * (col.span || 1);\n    }\n  }\n  return total;\n}\nconst COL_GROUP_STAT_EQUALITY = {\n  cols: isColPropsEqual\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical, ...scrollEls) {\n  return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n  scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n  return new StickyScrolling(scrollEl, isRtl);\n}\nexport { ScrollGrid };","map":{"version":3,"names":["computeEdges","removeElement","findElements","translateRect","computeInnerRect","applyStyle","BaseComponent","setRef","getIsRtlScrollbarOnLeft","Scroller","isPropsEqual","Emitter","DelayedRunner","config","memoizeArraylike","renderMicroColGroup","RefMap","getScrollGridClassNames","getCanVGrowWithinCell","getSectionClassNames","getAllowYScrolling","getSectionHasLiquidHeight","renderChunkContent","memoizeHashlike","computeShrinkWidth","getScrollbarWidths","collectFromHash","mapHash","isArraysEqual","sanitizeShrinkWidth","hasShrinkWidth","compareObjs","isColPropsEqual","createRef","createElement","Fragment","getScrollCanvasOrigin","scrollEl","rect","getBoundingClientRect","edges","left","borderLeft","scrollbarLeft","getScrollFromLeftEdge","top","borderTop","scrollTop","el","scrollLeft","computedStyles","window","getComputedStyle","direction","getRtlScrollSystem","scrollWidth","clientWidth","setScrollFromLeftEdge","_rtlScrollSystem","detectRtlScrollSystem","document","style","position","width","height","overflow","fontSize","innerHTML","body","appendChild","system","STICKY_SELECTOR","StickyScrolling","constructor","isRtl","updateSize","els","elGeoms","queryElGeoms","viewportWidth","assignStickyPositions","canvasOrigin","parentBound","parentNode","elRect","textAlign","naturalBound","parseFloat","push","elWidth","elHeight","forEach","i","parentWidth","right","ClippedScroller","arguments","elRef","state","xScrollbarWidth","yScrollbarWidth","handleScroller","scroller","props","scrollerRef","handleSizing","overflowY","setState","getYScrollbarWidth","overflowX","getXScrollbarWidth","render","context","isScrollbarOnLeft","overcomeLeft","overcomeRight","overcomeBottom","forPrint","ref","className","liquid","scrollerElRef","maxHeight","liquidIsAbsolute","children","componentDidMount","addResizeHandler","getSnapshotBeforeUpdate","prevProps","simulateScrollLeft","componentDidUpdate","prevState","snapshot","scrollerEl","undefined","restoredScrollLeft","parseInt","componentWillUnmount","removeResizeHandler","needsXScrolling","needsYScrolling","WHEEL_EVENT_NAMES","split","ScrollListener","emitter","isScrolling","isTouching","isRecentlyWheeled","isRecentlyScrolled","wheelWaiter","_handleWheelWaited","bind","scrollWaiter","_handleScrollWaited","handleScroll","startScroll","trigger","request","handleWheel","handleTouchStart","handleTouchEnd","endScroll","addEventListener","passive","eventName","destroy","removeEventListener","clear","ScrollSyncer","isVertical","scrollEls","isPaused","scrollListeners","map","bindScroller","scrollListener","onScroll","isWheel","isTouch","masterEl","assignMaster","otherEl","onScrollEnd","on","forceScrollLeft","listener","forceScrollTop","SCROLLGRID_RESIZE_INTERVAL","ScrollGrid","compileColGroupStats","compileColGroupStat","isColGroupStatsEqual","renderMicroColGroups","clippedScrollerRefs","scrollerElRefs","_handleScrollerEl","chunkElRefs","_handleChunkEl","scrollSyncersBySection","scrollSyncersByColumn","rowUnstableMap","Map","rowInnerMaxHeightMap","anyRowHeightsChanged","recentSizingCnt","shrinkWidths","forceYScrollbars","forceXScrollbars","scrollerClientWidths","scrollerClientHeights","sectionRowMaxHeights","isForcedResize","sectionRowMaxHeightsChanged","allowSizing","otherState","size","computeSectionRowMaxHeights","Object","assign","computeShrinkWidths","computeScrollerDims","updateStickyScrolling","handleRowHeightChange","rowEl","isStable","set","delete","innerMaxHeight","getRowInnerMaxHeight","has","get","colGroupStats","colGroups","colGroup","microColGroupNodes","stat","cols","classNames","getDims","sectionConfigs","sections","configCnt","length","configI","currentConfig","headSectionNodes","bodySectionNodes","footSectionNodes","type","renderSection","isBuggy","roleAttrs","role","join","renderMacroColGroup","Boolean","sectionConfig","sectionIndex","isHeader","key","outerContent","chunks","chunkConfig","renderChunk","colGroupStat","microColGroupNode","chunkIndex","rowHeights","sectionCnt","chunksPerSection","index","sideScrollIndex","isVScrollSide","isLastSection","allowXScrolling","allowYScrolling","chunkVGrow","expandRows","tableMinWidth","totalColMinWidth","content","tableColGroupNode","clientHeight","syncRowHeights","rowSyncHeights","reportRowHeightChange","getStickyScrolling","initStickyScrolling","getScrollSyncersBySection","initScrollSyncer","destroyScrollSyncer","getScrollSyncersByColumn","updateScrollSyncers","destroyScrollSyncers","now","Date","lastSizingDate","valueOf","cnt","hasShrinkCol","chunkEls","collect","newHeightMap","sectionI","assignableHeights","rowHeightsByChunk","chunkI","chunkEl","currentMap","max","rowCnt","isEqualRowCnt","isOuterContent","chunkHeightSums","sumNumbers","maxTotalSum","Math","rowInChunkCnt","rowInChunkTotalHeight","rowInChunkHeightOthers","floor","rowInChunkHeightFirst","rowInChunkHeights","row","rowHeightsAcrossChunks","h","scrollbarWidth","sideScrollI","lastSectionI","currentScrollers","scrollerEls","harnessEl","y","x","argsByKey","getAll","stickyScrolling","scrollElsBySection","scrollElsByColumn","scrollElMap","startIndex","endIndex","col","getChunkConfigByIndex","scrollSyncer","addStateEquality","numbers","sum","n","innerHeights","getElHeight","offsetHeight","totalColWidth","colGroupConfig","sumColProp","propName","total","val","span","COL_GROUP_STAT_EQUALITY","stat0","stat1"],"sources":["C:/Users/erden/Videos/FInals/New folder/streamlit-calendar/streamlit_calendar/frontend/node_modules/@fullcalendar/scrollgrid/internal.js"],"sourcesContent":["import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n    let rect = scrollEl.getBoundingClientRect();\n    let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n    return {\n        left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n        top: rect.top + edges.borderTop - scrollEl.scrollTop,\n    };\n}\nfunction getScrollFromLeftEdge(el) {\n    let scrollLeft = el.scrollLeft;\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'negative':\n                scrollLeft *= -1; // convert to 'reverse'. fall through...\n            case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n                scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n        }\n    }\n    return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'reverse':\n                scrollLeft = el.scrollWidth - scrollLeft;\n                break;\n            case 'negative':\n                scrollLeft = -(el.scrollWidth - scrollLeft);\n                break;\n        }\n    }\n    el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nlet _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n    let el = document.createElement('div');\n    el.style.position = 'absolute';\n    el.style.top = '-1000px';\n    el.style.width = '1px';\n    el.style.height = '1px';\n    el.style.overflow = 'scroll';\n    el.style.direction = 'rtl';\n    el.style.fontSize = '100px';\n    el.innerHTML = 'A';\n    document.body.appendChild(el);\n    let system;\n    if (el.scrollLeft > 0) {\n        system = 'positive'; // scroll is a positive number from the left edge\n    }\n    else {\n        el.scrollLeft = 1;\n        if (el.scrollLeft > 0) {\n            system = 'reverse'; // scroll is a positive number from the right edge\n        }\n        else {\n            system = 'negative'; // scroll is a negative number from the right edge\n        }\n    }\n    removeElement(el);\n    return system;\n}\n\nconst STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nclass StickyScrolling {\n    constructor(scrollEl, isRtl) {\n        this.scrollEl = scrollEl;\n        this.isRtl = isRtl;\n        this.updateSize = () => {\n            let { scrollEl } = this;\n            let els = findElements(scrollEl, STICKY_SELECTOR);\n            let elGeoms = this.queryElGeoms(els);\n            let viewportWidth = scrollEl.clientWidth;\n            assignStickyPositions(els, elGeoms, viewportWidth);\n        };\n    }\n    queryElGeoms(els) {\n        let { scrollEl, isRtl } = this;\n        let canvasOrigin = getScrollCanvasOrigin(scrollEl);\n        let elGeoms = [];\n        for (let el of els) {\n            let parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n            -canvasOrigin.left, -canvasOrigin.top);\n            let elRect = el.getBoundingClientRect();\n            let computedStyles = window.getComputedStyle(el);\n            let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n            let naturalBound = null;\n            if (textAlign === 'start') {\n                textAlign = isRtl ? 'right' : 'left';\n            }\n            else if (textAlign === 'end') {\n                textAlign = isRtl ? 'left' : 'right';\n            }\n            if (computedStyles.position !== 'sticky') {\n                naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n                -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n            }\n            elGeoms.push({\n                parentBound,\n                naturalBound,\n                elWidth: elRect.width,\n                elHeight: elRect.height,\n                textAlign,\n            });\n        }\n        return elGeoms;\n    }\n}\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n    els.forEach((el, i) => {\n        let { textAlign, elWidth, parentBound } = elGeoms[i];\n        let parentWidth = parentBound.right - parentBound.left;\n        let left;\n        if (textAlign === 'center' &&\n            parentWidth > viewportWidth) {\n            left = (viewportWidth - elWidth) / 2;\n        }\n        else { // if parent container can be completely in view, we don't need stickiness\n            left = '';\n        }\n        applyStyle(el, {\n            left,\n            right: left,\n            top: 0,\n        });\n    });\n}\n\nclass ClippedScroller extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.elRef = createRef();\n        this.state = {\n            xScrollbarWidth: 0,\n            yScrollbarWidth: 0,\n        };\n        this.handleScroller = (scroller) => {\n            this.scroller = scroller;\n            setRef(this.props.scrollerRef, scroller);\n        };\n        this.handleSizing = () => {\n            let { props } = this;\n            if (props.overflowY === 'scroll-hidden') {\n                this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });\n            }\n            if (props.overflowX === 'scroll-hidden') {\n                this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n        let overcomeLeft = 0;\n        let overcomeRight = 0;\n        let overcomeBottom = 0;\n        let { overflowX, overflowY } = props;\n        if (props.forPrint) {\n            overflowX = 'visible';\n            overflowY = 'visible';\n        }\n        if (overflowX === 'scroll-hidden') {\n            overcomeBottom = state.xScrollbarWidth;\n        }\n        if (overflowY === 'scroll-hidden') {\n            if (state.yScrollbarWidth != null) {\n                if (isScrollbarOnLeft) {\n                    overcomeLeft = state.yScrollbarWidth;\n                }\n                else {\n                    overcomeRight = state.yScrollbarWidth;\n                }\n            }\n        }\n        return (createElement(\"div\", { ref: this.elRef, className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '') },\n            createElement(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX, overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY, overcomeLeft: overcomeLeft, overcomeRight: overcomeRight, overcomeBottom: overcomeBottom, maxHeight: typeof props.maxHeight === 'number'\n                    ? (props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n                    : '', liquid: props.liquid, liquidIsAbsolute: true }, props.children)));\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        if (this.props.forPrint && !prevProps.forPrint) {\n            return { simulateScrollLeft: this.scroller.el.scrollLeft };\n        }\n        return {};\n    }\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        const { props, scroller: { el: scrollerEl } } = this;\n        if (!isPropsEqual(prevProps, props)) { // an external change?\n            this.handleSizing();\n        }\n        if (snapshot.simulateScrollLeft !== undefined) {\n            scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n        }\n        else if (!props.forPrint && prevProps.forPrint) {\n            const restoredScrollLeft = -parseInt(scrollerEl.style.left);\n            scrollerEl.style.left = '';\n            scrollerEl.scrollLeft = restoredScrollLeft;\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    needsXScrolling() {\n        return this.scroller.needsXScrolling();\n    }\n    needsYScrolling() {\n        return this.scroller.needsYScrolling();\n    }\n}\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nclass ScrollListener {\n    constructor(el) {\n        this.el = el;\n        this.emitter = new Emitter();\n        this.isScrolling = false;\n        this.isTouching = false; // user currently has finger down?\n        this.isRecentlyWheeled = false;\n        this.isRecentlyScrolled = false;\n        this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n        this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n        // Handlers\n        // ----------------------------------------------------------------------------------------------\n        this.handleScroll = () => {\n            this.startScroll();\n            this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\n            this.isRecentlyScrolled = true;\n            this.scrollWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleWheel = () => {\n            this.isRecentlyWheeled = true;\n            this.wheelWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleTouchStart = () => {\n            this.isTouching = true;\n        };\n        this.handleTouchEnd = () => {\n            this.isTouching = false;\n            // if the user ended their touch, and the scroll area wasn't moving,\n            // we consider this to be the end of the scroll.\n            if (!this.isRecentlyScrolled) {\n                this.endScroll(); // won't fire if already ended\n            }\n        };\n        el.addEventListener('scroll', this.handleScroll);\n        el.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.addEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.addEventListener(eventName, this.handleWheel);\n        }\n    }\n    destroy() {\n        let { el } = this;\n        el.removeEventListener('scroll', this.handleScroll);\n        el.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.removeEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.removeEventListener(eventName, this.handleWheel);\n        }\n    }\n    // Start / Stop\n    // ----------------------------------------------------------------------------------------------\n    startScroll() {\n        if (!this.isScrolling) {\n            this.isScrolling = true;\n            this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n        }\n    }\n    endScroll() {\n        if (this.isScrolling) {\n            this.emitter.trigger('scrollEnd');\n            this.isScrolling = false;\n            this.isRecentlyScrolled = true;\n            this.isRecentlyWheeled = false;\n            this.scrollWaiter.clear();\n            this.wheelWaiter.clear();\n        }\n    }\n    _handleScrollWaited() {\n        this.isRecentlyScrolled = false;\n        // only end the scroll if not currently touching.\n        // if touching, the scrolling will end later, on touchend.\n        if (!this.isTouching) {\n            this.endScroll(); // won't fire if already ended\n        }\n    }\n    _handleWheelWaited() {\n        this.isRecentlyWheeled = false;\n    }\n}\n\nclass ScrollSyncer {\n    constructor(isVertical, scrollEls) {\n        this.isVertical = isVertical;\n        this.scrollEls = scrollEls;\n        this.isPaused = false;\n        this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));\n    }\n    destroy() {\n        for (let scrollListener of this.scrollListeners) {\n            scrollListener.destroy();\n        }\n    }\n    bindScroller(el) {\n        let { scrollEls, isVertical } = this;\n        let scrollListener = new ScrollListener(el);\n        const onScroll = (isWheel, isTouch) => {\n            if (!this.isPaused) {\n                if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n                    this.assignMaster(el);\n                }\n                if (this.masterEl === el) { // dealing with current\n                    for (let otherEl of scrollEls) {\n                        if (otherEl !== el) {\n                            if (isVertical) {\n                                otherEl.scrollTop = el.scrollTop;\n                            }\n                            else {\n                                otherEl.scrollLeft = el.scrollLeft;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const onScrollEnd = () => {\n            if (this.masterEl === el) {\n                this.masterEl = null;\n            }\n        };\n        scrollListener.emitter.on('scroll', onScroll);\n        scrollListener.emitter.on('scrollEnd', onScrollEnd);\n        return scrollListener;\n    }\n    assignMaster(el) {\n        this.masterEl = el;\n        for (let scrollListener of this.scrollListeners) {\n            if (scrollListener.el !== el) {\n                scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n            }\n        }\n    }\n    /*\n    will normalize the scrollLeft value\n    */\n    forceScrollLeft(scrollLeft) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            setScrollFromLeftEdge(listener.el, scrollLeft);\n        }\n        this.isPaused = false;\n    }\n    forceScrollTop(top) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            listener.el.scrollTop = top;\n        }\n        this.isPaused = false;\n    }\n}\n\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nclass ScrollGrid extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n        this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n        this.clippedScrollerRefs = new RefMap();\n        // doesn't hold non-scrolling els used just for padding\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\n        this.scrollSyncersBySection = {};\n        this.scrollSyncersByColumn = {};\n        // for row-height-syncing\n        this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n        this.rowInnerMaxHeightMap = new Map();\n        this.anyRowHeightsChanged = false;\n        this.recentSizingCnt = 0;\n        this.state = {\n            shrinkWidths: [],\n            forceYScrollbars: false,\n            forceXScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {},\n            sectionRowMaxHeights: [],\n        };\n        this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\n            if (!this.allowSizing()) {\n                return;\n            }\n            if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n                this.anyRowHeightsChanged = true;\n            }\n            let otherState = {};\n            // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n            if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n                otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\n            }\n            this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {\n                if (!this.rowUnstableMap.size) {\n                    this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n                }\n            });\n        };\n        this.handleRowHeightChange = (rowEl, isStable) => {\n            let { rowUnstableMap, rowInnerMaxHeightMap } = this;\n            if (!isStable) {\n                rowUnstableMap.set(rowEl, true);\n            }\n            else {\n                rowUnstableMap.delete(rowEl);\n                let innerMaxHeight = getRowInnerMaxHeight(rowEl);\n                if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n                    rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n                    this.anyRowHeightsChanged = true;\n                }\n                if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n                    this.anyRowHeightsChanged = false;\n                    this.setState({\n                        sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n                    });\n                }\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { shrinkWidths } = state;\n        let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));\n        let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        this.getDims();\n        // TODO: make DRY\n        let sectionConfigs = props.sections;\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n            headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n            bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n            footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n        const roleAttrs = { role: 'rowgroup' };\n        return createElement('table', {\n            ref: props.elRef,\n            role: 'grid',\n            className: classNames.join(' '),\n        }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n        if ('outerContent' in sectionConfig) {\n            return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n        }\n        return (createElement(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader))));\n    }\n    renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n        if ('outerContent' in chunkConfig) {\n            return (createElement(Fragment, { key: chunkConfig.key }, chunkConfig.outerContent));\n        }\n        let { state } = this;\n        let { scrollerClientWidths, scrollerClientHeights } = state;\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let index = sectionIndex * chunksPerSection + chunkIndex;\n        let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let isVScrollSide = chunkIndex === sideScrollIndex;\n        let isLastSection = sectionIndex === sectionCnt - 1;\n        let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n        let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n        let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n        let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n        let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n        let expandRows = sectionConfig.expandRows && chunkVGrow;\n        let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || '';\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth,\n            clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n            clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n            expandRows,\n            syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n            rowSyncHeights: rowHeights,\n            reportRowHeightChange: this.handleRowHeightChange,\n        }, isHeader);\n        let overflowX = forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n            !allowXScrolling ? 'hidden' :\n                (isLastSection ? 'auto' : 'scroll-hidden');\n        let overflowY = forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n            !allowYScrolling ? 'hidden' :\n                (isVScrollSide ? 'auto' : 'scroll-hidden');\n        // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n        // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n        content = (createElement(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index), scrollerElRef: this.scrollerElRefs.createRef(index), overflowX: overflowX, overflowY: overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content));\n        return createElement(isHeader ? 'th' : 'td', {\n            key: chunkConfig.key,\n            ref: this.chunkElRefs.createRef(index),\n            role: 'presentation',\n        }, content);\n    }\n    componentDidMount() {\n        this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n        this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n        this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n        this.updateScrollSyncers();\n        this.handleSizing(false);\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        this.updateScrollSyncers();\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n        this.destroyScrollSyncers();\n    }\n    allowSizing() {\n        let now = new Date();\n        if (!this.lastSizingDate ||\n            now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n            this.lastSizingDate = now;\n            this.recentSizingCnt = 0;\n            return true;\n        }\n        return (this.recentSizingCnt += 1) <= 10;\n    }\n    computeShrinkWidths() {\n        let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let shrinkWidths = [];\n        colGroupStats.forEach((colGroupStat, i) => {\n            if (colGroupStat.hasShrinkCol) {\n                let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n                shrinkWidths[i] = computeShrinkWidth(chunkEls);\n            }\n        });\n        return shrinkWidths;\n    }\n    // has the side effect of grooming rowInnerMaxHeightMap\n    // TODO: somehow short-circuit if there are no new height changes\n    computeSectionRowMaxHeights() {\n        let newHeightMap = new Map();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sectionRowMaxHeights = [];\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let sectionConfig = this.props.sections[sectionI];\n            let assignableHeights = []; // chunk, row\n            if (sectionConfig && sectionConfig.syncRowHeights) {\n                let rowHeightsByChunk = [];\n                for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                    let index = sectionI * chunksPerSection + chunkI;\n                    let rowHeights = [];\n                    let chunkEl = this.chunkElRefs.currentMap[index];\n                    if (chunkEl) {\n                        rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl) => {\n                            let max = getRowInnerMaxHeight(rowEl);\n                            newHeightMap.set(rowEl, max);\n                            return max;\n                        });\n                    }\n                    else {\n                        rowHeights = [];\n                    }\n                    rowHeightsByChunk.push(rowHeights);\n                }\n                let rowCnt = rowHeightsByChunk[0].length;\n                let isEqualRowCnt = true;\n                for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n                    let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n                    if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n                        isEqualRowCnt = false;\n                        break;\n                    }\n                }\n                if (!isEqualRowCnt) {\n                    let chunkHeightSums = [];\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n                    }\n                    let maxTotalSum = Math.max(...chunkHeightSums);\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n                        let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n                        // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n                        let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n                        // whatever is leftover goes to the first row\n                        let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n                        let rowInChunkHeights = [];\n                        let row = 0;\n                        if (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightFirst);\n                            row += 1;\n                        }\n                        while (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightOthers);\n                            row += 1;\n                        }\n                        assignableHeights.push(rowInChunkHeights);\n                    }\n                }\n                else {\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        assignableHeights.push([]);\n                    }\n                    for (let row = 0; row < rowCnt; row += 1) {\n                        let rowHeightsAcrossChunks = [];\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            let h = rowHeightsByChunk[chunkI][row];\n                            if (h != null) { // protect against outerContent\n                                rowHeightsAcrossChunks.push(h);\n                            }\n                        }\n                        let maxHeight = Math.max(...rowHeightsAcrossChunks);\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            assignableHeights[chunkI].push(maxHeight);\n                        }\n                    }\n                }\n            }\n            sectionRowMaxHeights.push(assignableHeights);\n        }\n        this.rowInnerMaxHeightMap = newHeightMap;\n        return sectionRowMaxHeights;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let lastSectionI = sectionCnt - 1;\n        let currentScrollers = this.clippedScrollerRefs.currentMap;\n        let scrollerEls = this.scrollerElRefs.currentMap;\n        let forceYScrollbars = false;\n        let forceXScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n            let index = sectionI * chunksPerSection + sideScrollI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n            let index = lastSectionI * chunksPerSection + chunkI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsXScrolling()) {\n                forceXScrollbars = true;\n                break;\n            }\n        }\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                let index = sectionI * chunksPerSection + chunkI;\n                let scrollerEl = scrollerEls[index];\n                if (scrollerEl) {\n                    // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    let harnessEl = scrollerEl.parentNode;\n                    scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - ((chunkI === sideScrollI && forceYScrollbars)\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                    scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - ((sectionI === lastSectionI && forceXScrollbars)\n                        ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                }\n            }\n        }\n        return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };\n    }\n    updateStickyScrolling() {\n        let { isRtl } = this.context;\n        let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);\n        this.getStickyScrolling(argsByKey)\n            .forEach((stickyScrolling) => stickyScrolling.updateSize());\n    }\n    updateScrollSyncers() {\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let scrollElsBySection = {};\n        let scrollElsByColumn = {};\n        let scrollElMap = this.scrollerElRefs.currentMap;\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let startIndex = sectionI * chunksPerSection;\n            let endIndex = startIndex + chunksPerSection;\n            scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n        }\n        for (let col = 0; col < chunksPerSection; col += 1) {\n            scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n        }\n        this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n        this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n    }\n    destroyScrollSyncers() {\n        mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n        mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n    }\n    getChunkConfigByIndex(index) {\n        let chunksPerSection = this.getDims()[1];\n        let sectionI = Math.floor(index / chunksPerSection);\n        let chunkI = index % chunksPerSection;\n        let sectionConfig = this.props.sections[sectionI];\n        return sectionConfig && sectionConfig.chunks[chunkI];\n    }\n    forceScrollLeft(col, scrollLeft) {\n        let scrollSyncer = this.scrollSyncersByColumn[col];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollLeft(scrollLeft);\n        }\n    }\n    forceScrollTop(sectionI, scrollTop) {\n        let scrollSyncer = this.scrollSyncersBySection[sectionI];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollTop(scrollTop);\n        }\n    }\n    _handleChunkEl(chunkEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.elRef, chunkEl);\n        }\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\n        }\n    }\n    getDims() {\n        let sectionCnt = this.props.sections.length;\n        let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n        return [sectionCnt, chunksPerSection];\n    }\n}\nScrollGrid.addStateEquality({\n    shrinkWidths: isArraysEqual,\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual,\n});\nfunction sumNumbers(numbers) {\n    let sum = 0;\n    for (let n of numbers) {\n        sum += n;\n    }\n    return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n    let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n    if (innerHeights.length) {\n        return Math.max(...innerHeights);\n    }\n    return 0;\n}\nfunction getElHeight(el) {\n    return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n    let children = colGroupStats.map((colGroupStat, i) => {\n        let width = colGroupStat.width;\n        if (width === 'shrink') {\n            width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n        }\n        return ( // eslint-disable-next-line react/jsx-key\n        createElement(\"col\", { style: { width } }));\n    });\n    return createElement('colgroup', {}, ...children);\n}\nfunction compileColGroupStat(colGroupConfig) {\n    let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n    let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n    let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n    let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n    return {\n        hasShrinkCol,\n        totalColWidth,\n        totalColMinWidth,\n        allowXScrolling,\n        cols: colGroupConfig.cols,\n        width: colGroupConfig.width,\n    };\n}\nfunction sumColProp(cols, propName) {\n    let total = 0;\n    for (let col of cols) {\n        let val = col[propName];\n        if (typeof val === 'number') {\n            total += val * (col.span || 1);\n        }\n    }\n    return total;\n}\nconst COL_GROUP_STAT_EQUALITY = {\n    cols: isColPropsEqual,\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n    return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical, ...scrollEls) {\n    return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n    scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n    return new StickyScrolling(scrollEl, isRtl);\n}\n\nexport { ScrollGrid };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}